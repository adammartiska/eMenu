{"ast":null,"code":"/**\n * Produces the value of a block string from its parsed raw value, similar to\n * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.\n *\n * This implements the GraphQL spec's BlockStringValue() static algorithm.\n *\n * @internal\n */\nexport function dedentBlockStringValue(rawString) {\n  // Expand a block string's raw value into independent lines.\n  const lines = rawString.split(/\\r\\n|[\\n\\r]/g); // Remove common indentation from all lines but first.\n\n  const commonIndent = getBlockStringIndentation(rawString);\n\n  if (commonIndent !== 0) {\n    for (let i = 1; i < lines.length; i++) {\n      lines[i] = lines[i].slice(commonIndent);\n    }\n  } // Remove leading and trailing blank lines.\n\n\n  let startLine = 0;\n\n  while (startLine < lines.length && isBlank(lines[startLine])) {\n    ++startLine;\n  }\n\n  let endLine = lines.length;\n\n  while (endLine > startLine && isBlank(lines[endLine - 1])) {\n    --endLine;\n  } // Return a string of the lines joined with U+000A.\n\n\n  return lines.slice(startLine, endLine).join('\\n');\n}\n\nfunction isBlank(str) {\n  for (const char of str) {\n    if (char !== ' ' && char !== '\\t') {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * @internal\n */\n\n\nexport function getBlockStringIndentation(value) {\n  var _commonIndent;\n\n  let isFirstLine = true;\n  let isEmptyLine = true;\n  let indent = 0;\n  let commonIndent = null;\n\n  for (let i = 0; i < value.length; ++i) {\n    switch (value.charCodeAt(i)) {\n      case 13:\n        //  \\r\n        if (value.charCodeAt(i + 1) === 10) {\n          ++i; // skip \\r\\n as one symbol\n        }\n\n      // falls through\n\n      case 10:\n        //  \\n\n        isFirstLine = false;\n        isEmptyLine = true;\n        indent = 0;\n        break;\n\n      case 9: //   \\t\n\n      case 32:\n        //  <space>\n        ++indent;\n        break;\n\n      default:\n        if (isEmptyLine && !isFirstLine && (commonIndent === null || indent < commonIndent)) {\n          commonIndent = indent;\n        }\n\n        isEmptyLine = false;\n    }\n  }\n\n  return (_commonIndent = commonIndent) !== null && _commonIndent !== void 0 ? _commonIndent : 0;\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n *\n * @internal\n */\n\nexport function printBlockString(value, preferMultipleLines = false) {\n  const isSingleLine = !value.includes('\\n');\n  const hasLeadingSpace = value.startsWith(' ') || value.startsWith('\\t');\n  const hasTrailingQuote = value.endsWith('\"');\n  const hasTrailingSlash = value.endsWith('\\\\');\n  const printAsMultipleLines = !isSingleLine || hasTrailingQuote || hasTrailingSlash || preferMultipleLines;\n  let result = ''; // Format a multi-line block quote to account for leading space.\n\n  if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {\n    result += '\\n';\n  }\n\n  result += value;\n\n  if (printAsMultipleLines) {\n    result += '\\n';\n  }\n\n  return '\"\"\"' + result.replace(/\"\"\"/g, '\\\\\"\"\"') + '\"\"\"';\n}","map":{"version":3,"sources":["/Users/adammartiska/Projects/eMenu/GUI/eMenu-customer/node_modules/graphql/language/blockString.mjs"],"names":["dedentBlockStringValue","rawString","lines","split","commonIndent","getBlockStringIndentation","i","length","slice","startLine","isBlank","endLine","join","str","char","value","_commonIndent","isFirstLine","isEmptyLine","indent","charCodeAt","printBlockString","preferMultipleLines","isSingleLine","includes","hasLeadingSpace","startsWith","hasTrailingQuote","endsWith","hasTrailingSlash","printAsMultipleLines","result","replace"],"mappings":"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","sourcesContent":["/**\n * Produces the value of a block string from its parsed raw value, similar to\n * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.\n *\n * This implements the GraphQL spec's BlockStringValue() static algorithm.\n *\n * @internal\n */\nexport function dedentBlockStringValue(rawString) {\n  // Expand a block string's raw value into independent lines.\n  const lines = rawString.split(/\\r\\n|[\\n\\r]/g); // Remove common indentation from all lines but first.\n\n  const commonIndent = getBlockStringIndentation(rawString);\n\n  if (commonIndent !== 0) {\n    for (let i = 1; i < lines.length; i++) {\n      lines[i] = lines[i].slice(commonIndent);\n    }\n  } // Remove leading and trailing blank lines.\n\n  let startLine = 0;\n\n  while (startLine < lines.length && isBlank(lines[startLine])) {\n    ++startLine;\n  }\n\n  let endLine = lines.length;\n\n  while (endLine > startLine && isBlank(lines[endLine - 1])) {\n    --endLine;\n  } // Return a string of the lines joined with U+000A.\n\n  return lines.slice(startLine, endLine).join('\\n');\n}\n\nfunction isBlank(str) {\n  for (const char of str) {\n    if (char !== ' ' && char !== '\\t') {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * @internal\n */\n\nexport function getBlockStringIndentation(value) {\n  var _commonIndent;\n\n  let isFirstLine = true;\n  let isEmptyLine = true;\n  let indent = 0;\n  let commonIndent = null;\n\n  for (let i = 0; i < value.length; ++i) {\n    switch (value.charCodeAt(i)) {\n      case 13:\n        //  \\r\n        if (value.charCodeAt(i + 1) === 10) {\n          ++i; // skip \\r\\n as one symbol\n        }\n\n      // falls through\n\n      case 10:\n        //  \\n\n        isFirstLine = false;\n        isEmptyLine = true;\n        indent = 0;\n        break;\n\n      case 9: //   \\t\n\n      case 32:\n        //  <space>\n        ++indent;\n        break;\n\n      default:\n        if (\n          isEmptyLine &&\n          !isFirstLine &&\n          (commonIndent === null || indent < commonIndent)\n        ) {\n          commonIndent = indent;\n        }\n\n        isEmptyLine = false;\n    }\n  }\n\n  return (_commonIndent = commonIndent) !== null && _commonIndent !== void 0\n    ? _commonIndent\n    : 0;\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n *\n * @internal\n */\n\nexport function printBlockString(value, preferMultipleLines = false) {\n  const isSingleLine = !value.includes('\\n');\n  const hasLeadingSpace = value.startsWith(' ') || value.startsWith('\\t');\n  const hasTrailingQuote = value.endsWith('\"');\n  const hasTrailingSlash = value.endsWith('\\\\');\n  const printAsMultipleLines =\n    !isSingleLine ||\n    hasTrailingQuote ||\n    hasTrailingSlash ||\n    preferMultipleLines;\n  let result = ''; // Format a multi-line block quote to account for leading space.\n\n  if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {\n    result += '\\n';\n  }\n\n  result += value;\n\n  if (printAsMultipleLines) {\n    result += '\\n';\n  }\n\n  return '\"\"\"' + result.replace(/\"\"\"/g, '\\\\\"\"\"') + '\"\"\"';\n}\n"]},"metadata":{},"sourceType":"module"}