{"ast":null,"code":"import { isCancelable } from './retryer';\nimport { getAbortController } from './utils';\nexport function infiniteQueryBehavior() {\n  return {\n    onFetch: function onFetch(context) {\n      context.fetchFn = function () {\n        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;\n\n        var refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;\n        var fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;\n        var pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;\n        var isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'forward';\n        var isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'backward';\n        var oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];\n        var oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];\n        var abortController = getAbortController();\n        var abortSignal = abortController == null ? void 0 : abortController.signal;\n        var newPageParams = oldPageParams;\n        var cancelled = false; // Get query function\n\n        var queryFn = context.options.queryFn || function () {\n          return Promise.reject('Missing queryFn');\n        };\n\n        var buildNewPages = function buildNewPages(pages, param, page, previous) {\n          newPageParams = previous ? [param].concat(newPageParams) : [].concat(newPageParams, [param]);\n          return previous ? [page].concat(pages) : [].concat(pages, [page]);\n        }; // Create function to fetch a page\n\n\n        var fetchPage = function fetchPage(pages, manual, param, previous) {\n          if (cancelled) {\n            return Promise.reject('Cancelled');\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages);\n          }\n\n          var queryFnContext = {\n            queryKey: context.queryKey,\n            signal: abortSignal,\n            pageParam: param,\n            meta: context.meta\n          };\n          var queryFnResult = queryFn(queryFnContext);\n          var promise = Promise.resolve(queryFnResult).then(function (page) {\n            return buildNewPages(pages, param, page, previous);\n          });\n\n          if (isCancelable(queryFnResult)) {\n            var promiseAsAny = promise;\n            promiseAsAny.cancel = queryFnResult.cancel;\n          }\n\n          return promise;\n        };\n\n        var promise; // Fetch first page?\n\n        if (!oldPages.length) {\n          promise = fetchPage([]);\n        } // Fetch next page?\n        else if (isFetchingNextPage) {\n          var manual = typeof pageParam !== 'undefined';\n          var param = manual ? pageParam : getNextPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param);\n        } // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          var _manual = typeof pageParam !== 'undefined';\n\n          var _param = _manual ? pageParam : getPreviousPageParam(context.options, oldPages);\n\n          promise = fetchPage(oldPages, _manual, _param, true);\n        } // Refetch pages\n        else {\n          (function () {\n            newPageParams = [];\n            var manual = typeof context.options.getNextPageParam === 'undefined';\n            var shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true; // Fetch first page\n\n            promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0])); // Fetch remaining pages\n\n            var _loop = function _loop(i) {\n              promise = promise.then(function (pages) {\n                var shouldFetchNextPage = refetchPage && oldPages[i] ? refetchPage(oldPages[i], i, oldPages) : true;\n\n                if (shouldFetchNextPage) {\n                  var _param2 = manual ? oldPageParams[i] : getNextPageParam(context.options, pages);\n\n                  return fetchPage(pages, manual, _param2);\n                }\n\n                return Promise.resolve(buildNewPages(pages, oldPageParams[i], oldPages[i]));\n              });\n            };\n\n            for (var i = 1; i < oldPages.length; i++) {\n              _loop(i);\n            }\n          })();\n        }\n\n        var finalPromise = promise.then(function (pages) {\n          return {\n            pages: pages,\n            pageParams: newPageParams\n          };\n        });\n        var finalPromiseAsAny = finalPromise;\n\n        finalPromiseAsAny.cancel = function () {\n          cancelled = true;\n          abortController == null ? void 0 : abortController.abort();\n\n          if (isCancelable(promise)) {\n            promise.cancel();\n          }\n        };\n\n        return finalPromise;\n      };\n    }\n  };\n}\nexport function getNextPageParam(options, pages) {\n  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);\n}\nexport function getPreviousPageParam(options, pages) {\n  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);\n}\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\n\nexport function hasNextPage(options, pages) {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    var nextPageParam = getNextPageParam(options, pages);\n    return typeof nextPageParam !== 'undefined' && nextPageParam !== null && nextPageParam !== false;\n  }\n}\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\n\nexport function hasPreviousPage(options, pages) {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    var previousPageParam = getPreviousPageParam(options, pages);\n    return typeof previousPageParam !== 'undefined' && previousPageParam !== null && previousPageParam !== false;\n  }\n}","map":{"version":3,"sources":["/Users/adammartiska/Projects/eMenu/GUI/eMenu-customer/node_modules/react-query/es/core/infiniteQueryBehavior.js"],"names":["isCancelable","getAbortController","infiniteQueryBehavior","onFetch","context","fetchFn","_context$fetchOptions","_context$fetchOptions2","_context$fetchOptions3","_context$fetchOptions4","_context$state$data","_context$state$data2","refetchPage","fetchOptions","meta","fetchMore","pageParam","isFetchingNextPage","direction","isFetchingPreviousPage","oldPages","state","data","pages","oldPageParams","pageParams","abortController","abortSignal","signal","newPageParams","cancelled","queryFn","options","Promise","reject","buildNewPages","param","page","previous","concat","fetchPage","manual","length","resolve","queryFnContext","queryKey","queryFnResult","promise","then","promiseAsAny","cancel","getNextPageParam","_manual","_param","getPreviousPageParam","shouldFetchFirstPage","_loop","i","shouldFetchNextPage","_param2","finalPromise","finalPromiseAsAny","abort","hasNextPage","Array","isArray","nextPageParam","hasPreviousPage","previousPageParam"],"mappings":"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","sourcesContent":["import { isCancelable } from './retryer';\nimport { getAbortController } from './utils';\nexport function infiniteQueryBehavior() {\n  return {\n    onFetch: function onFetch(context) {\n      context.fetchFn = function () {\n        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;\n\n        var refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;\n        var fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;\n        var pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;\n        var isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'forward';\n        var isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'backward';\n        var oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];\n        var oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];\n        var abortController = getAbortController();\n        var abortSignal = abortController == null ? void 0 : abortController.signal;\n        var newPageParams = oldPageParams;\n        var cancelled = false; // Get query function\n\n        var queryFn = context.options.queryFn || function () {\n          return Promise.reject('Missing queryFn');\n        };\n\n        var buildNewPages = function buildNewPages(pages, param, page, previous) {\n          newPageParams = previous ? [param].concat(newPageParams) : [].concat(newPageParams, [param]);\n          return previous ? [page].concat(pages) : [].concat(pages, [page]);\n        }; // Create function to fetch a page\n\n\n        var fetchPage = function fetchPage(pages, manual, param, previous) {\n          if (cancelled) {\n            return Promise.reject('Cancelled');\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages);\n          }\n\n          var queryFnContext = {\n            queryKey: context.queryKey,\n            signal: abortSignal,\n            pageParam: param,\n            meta: context.meta\n          };\n          var queryFnResult = queryFn(queryFnContext);\n          var promise = Promise.resolve(queryFnResult).then(function (page) {\n            return buildNewPages(pages, param, page, previous);\n          });\n\n          if (isCancelable(queryFnResult)) {\n            var promiseAsAny = promise;\n            promiseAsAny.cancel = queryFnResult.cancel;\n          }\n\n          return promise;\n        };\n\n        var promise; // Fetch first page?\n\n        if (!oldPages.length) {\n          promise = fetchPage([]);\n        } // Fetch next page?\n        else if (isFetchingNextPage) {\n            var manual = typeof pageParam !== 'undefined';\n            var param = manual ? pageParam : getNextPageParam(context.options, oldPages);\n            promise = fetchPage(oldPages, manual, param);\n          } // Fetch previous page?\n          else if (isFetchingPreviousPage) {\n              var _manual = typeof pageParam !== 'undefined';\n\n              var _param = _manual ? pageParam : getPreviousPageParam(context.options, oldPages);\n\n              promise = fetchPage(oldPages, _manual, _param, true);\n            } // Refetch pages\n            else {\n                (function () {\n                  newPageParams = [];\n                  var manual = typeof context.options.getNextPageParam === 'undefined';\n                  var shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true; // Fetch first page\n\n                  promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0])); // Fetch remaining pages\n\n                  var _loop = function _loop(i) {\n                    promise = promise.then(function (pages) {\n                      var shouldFetchNextPage = refetchPage && oldPages[i] ? refetchPage(oldPages[i], i, oldPages) : true;\n\n                      if (shouldFetchNextPage) {\n                        var _param2 = manual ? oldPageParams[i] : getNextPageParam(context.options, pages);\n\n                        return fetchPage(pages, manual, _param2);\n                      }\n\n                      return Promise.resolve(buildNewPages(pages, oldPageParams[i], oldPages[i]));\n                    });\n                  };\n\n                  for (var i = 1; i < oldPages.length; i++) {\n                    _loop(i);\n                  }\n                })();\n              }\n\n        var finalPromise = promise.then(function (pages) {\n          return {\n            pages: pages,\n            pageParams: newPageParams\n          };\n        });\n        var finalPromiseAsAny = finalPromise;\n\n        finalPromiseAsAny.cancel = function () {\n          cancelled = true;\n          abortController == null ? void 0 : abortController.abort();\n\n          if (isCancelable(promise)) {\n            promise.cancel();\n          }\n        };\n\n        return finalPromise;\n      };\n    }\n  };\n}\nexport function getNextPageParam(options, pages) {\n  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);\n}\nexport function getPreviousPageParam(options, pages) {\n  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);\n}\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\n\nexport function hasNextPage(options, pages) {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    var nextPageParam = getNextPageParam(options, pages);\n    return typeof nextPageParam !== 'undefined' && nextPageParam !== null && nextPageParam !== false;\n  }\n}\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\n\nexport function hasPreviousPage(options, pages) {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    var previousPageParam = getPreviousPageParam(options, pages);\n    return typeof previousPageParam !== 'undefined' && previousPageParam !== null && previousPageParam !== false;\n  }\n}"]},"metadata":{},"sourceType":"module"}