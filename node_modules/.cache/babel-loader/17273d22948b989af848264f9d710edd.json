{"ast":null,"code":"import { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { didYouMean } from '../jsutils/didYouMean.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { suggestionList } from '../jsutils/suggestionList.mjs';\nimport { printPathArray } from '../jsutils/printPathArray.mjs';\nimport { addPath, pathToArray } from '../jsutils/Path.mjs';\nimport { isIterableObject } from '../jsutils/isIterableObject.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { isLeafType, isInputObjectType, isListType, isNonNullType } from '../type/definition.mjs';\n/**\n * Coerces a JavaScript value given a GraphQL Input Type.\n */\n\nexport function coerceInputValue(inputValue, type) {\n  let onError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultOnError;\n  return coerceInputValueImpl(inputValue, type, onError, undefined);\n}\n\nfunction defaultOnError(path, invalidValue, error) {\n  let errorPrefix = 'Invalid value ' + inspect(invalidValue);\n\n  if (path.length > 0) {\n    errorPrefix += ` at \"value${printPathArray(path)}\"`;\n  }\n\n  error.message = errorPrefix + ': ' + error.message;\n  throw error;\n}\n\nfunction coerceInputValueImpl(inputValue, type, onError, path) {\n  if (isNonNullType(type)) {\n    if (inputValue != null) {\n      return coerceInputValueImpl(inputValue, type.ofType, onError, path);\n    }\n\n    onError(pathToArray(path), inputValue, new GraphQLError(`Expected non-nullable type \"${inspect(type)}\" not to be null.`));\n    return;\n  }\n\n  if (inputValue == null) {\n    // Explicitly return the value null.\n    return null;\n  }\n\n  if (isListType(type)) {\n    const itemType = type.ofType;\n\n    if (isIterableObject(inputValue)) {\n      return Array.from(inputValue, (itemValue, index) => {\n        const itemPath = addPath(path, index, undefined);\n        return coerceInputValueImpl(itemValue, itemType, onError, itemPath);\n      });\n    } // Lists accept a non-list value as a list of one.\n\n\n    return [coerceInputValueImpl(inputValue, itemType, onError, path)];\n  }\n\n  if (isInputObjectType(type)) {\n    if (!isObjectLike(inputValue)) {\n      onError(pathToArray(path), inputValue, new GraphQLError(`Expected type \"${type.name}\" to be an object.`));\n      return;\n    }\n\n    const coercedValue = {};\n    const fieldDefs = type.getFields();\n\n    for (const field of Object.values(fieldDefs)) {\n      const fieldValue = inputValue[field.name];\n\n      if (fieldValue === undefined) {\n        if (field.defaultValue !== undefined) {\n          coercedValue[field.name] = field.defaultValue;\n        } else if (isNonNullType(field.type)) {\n          const typeStr = inspect(field.type);\n          onError(pathToArray(path), inputValue, new GraphQLError(`Field \"${field.name}\" of required type \"${typeStr}\" was not provided.`));\n        }\n\n        continue;\n      }\n\n      coercedValue[field.name] = coerceInputValueImpl(fieldValue, field.type, onError, addPath(path, field.name, type.name));\n    } // Ensure every provided field is defined.\n\n\n    for (const fieldName of Object.keys(inputValue)) {\n      if (!fieldDefs[fieldName]) {\n        const suggestions = suggestionList(fieldName, Object.keys(type.getFields()));\n        onError(pathToArray(path), inputValue, new GraphQLError(`Field \"${fieldName}\" is not defined by type \"${type.name}\".` + didYouMean(suggestions)));\n      }\n    }\n\n    return coercedValue;\n  }\n\n  if (isLeafType(type)) {\n    let parseResult; // Scalars and Enums determine if a input value is valid via parseValue(),\n    // which can throw to indicate failure. If it throws, maintain a reference\n    // to the original error.\n\n    try {\n      parseResult = type.parseValue(inputValue);\n    } catch (error) {\n      if (error instanceof GraphQLError) {\n        onError(pathToArray(path), inputValue, error);\n      } else {\n        onError(pathToArray(path), inputValue, new GraphQLError(`Expected type \"${type.name}\". ` + error.message, undefined, undefined, undefined, undefined, error));\n      }\n\n      return;\n    }\n\n    if (parseResult === undefined) {\n      onError(pathToArray(path), inputValue, new GraphQLError(`Expected type \"${type.name}\".`));\n    }\n\n    return parseResult;\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n\n  false || invariant(false, 'Unexpected input type: ' + inspect(type));\n}","map":{"version":3,"sources":["/Users/adammartiska/Projects/eMenu/GUI/eMenu-customer/node_modules/graphql/utilities/coerceInputValue.mjs"],"names":["inspect","invariant","didYouMean","isObjectLike","suggestionList","printPathArray","addPath","pathToArray","isIterableObject","GraphQLError","isLeafType","isInputObjectType","isListType","isNonNullType","coerceInputValue","inputValue","type","onError","defaultOnError","coerceInputValueImpl","undefined","path","invalidValue","error","errorPrefix","length","message","ofType","itemType","Array","from","itemValue","index","itemPath","name","coercedValue","fieldDefs","getFields","field","Object","values","fieldValue","defaultValue","typeStr","fieldName","keys","suggestions","parseResult","parseValue"],"mappings":"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","sourcesContent":["import { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { didYouMean } from '../jsutils/didYouMean.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { suggestionList } from '../jsutils/suggestionList.mjs';\nimport { printPathArray } from '../jsutils/printPathArray.mjs';\nimport { addPath, pathToArray } from '../jsutils/Path.mjs';\nimport { isIterableObject } from '../jsutils/isIterableObject.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport {\n  isLeafType,\n  isInputObjectType,\n  isListType,\n  isNonNullType,\n} from '../type/definition.mjs';\n\n/**\n * Coerces a JavaScript value given a GraphQL Input Type.\n */\nexport function coerceInputValue(inputValue, type, onError = defaultOnError) {\n  return coerceInputValueImpl(inputValue, type, onError, undefined);\n}\n\nfunction defaultOnError(path, invalidValue, error) {\n  let errorPrefix = 'Invalid value ' + inspect(invalidValue);\n\n  if (path.length > 0) {\n    errorPrefix += ` at \"value${printPathArray(path)}\"`;\n  }\n\n  error.message = errorPrefix + ': ' + error.message;\n  throw error;\n}\n\nfunction coerceInputValueImpl(inputValue, type, onError, path) {\n  if (isNonNullType(type)) {\n    if (inputValue != null) {\n      return coerceInputValueImpl(inputValue, type.ofType, onError, path);\n    }\n\n    onError(\n      pathToArray(path),\n      inputValue,\n      new GraphQLError(\n        `Expected non-nullable type \"${inspect(type)}\" not to be null.`,\n      ),\n    );\n    return;\n  }\n\n  if (inputValue == null) {\n    // Explicitly return the value null.\n    return null;\n  }\n\n  if (isListType(type)) {\n    const itemType = type.ofType;\n\n    if (isIterableObject(inputValue)) {\n      return Array.from(inputValue, (itemValue, index) => {\n        const itemPath = addPath(path, index, undefined);\n        return coerceInputValueImpl(itemValue, itemType, onError, itemPath);\n      });\n    } // Lists accept a non-list value as a list of one.\n\n    return [coerceInputValueImpl(inputValue, itemType, onError, path)];\n  }\n\n  if (isInputObjectType(type)) {\n    if (!isObjectLike(inputValue)) {\n      onError(\n        pathToArray(path),\n        inputValue,\n        new GraphQLError(`Expected type \"${type.name}\" to be an object.`),\n      );\n      return;\n    }\n\n    const coercedValue = {};\n    const fieldDefs = type.getFields();\n\n    for (const field of Object.values(fieldDefs)) {\n      const fieldValue = inputValue[field.name];\n\n      if (fieldValue === undefined) {\n        if (field.defaultValue !== undefined) {\n          coercedValue[field.name] = field.defaultValue;\n        } else if (isNonNullType(field.type)) {\n          const typeStr = inspect(field.type);\n          onError(\n            pathToArray(path),\n            inputValue,\n            new GraphQLError(\n              `Field \"${field.name}\" of required type \"${typeStr}\" was not provided.`,\n            ),\n          );\n        }\n\n        continue;\n      }\n\n      coercedValue[field.name] = coerceInputValueImpl(\n        fieldValue,\n        field.type,\n        onError,\n        addPath(path, field.name, type.name),\n      );\n    } // Ensure every provided field is defined.\n\n    for (const fieldName of Object.keys(inputValue)) {\n      if (!fieldDefs[fieldName]) {\n        const suggestions = suggestionList(\n          fieldName,\n          Object.keys(type.getFields()),\n        );\n        onError(\n          pathToArray(path),\n          inputValue,\n          new GraphQLError(\n            `Field \"${fieldName}\" is not defined by type \"${type.name}\".` +\n              didYouMean(suggestions),\n          ),\n        );\n      }\n    }\n\n    return coercedValue;\n  }\n\n  if (isLeafType(type)) {\n    let parseResult; // Scalars and Enums determine if a input value is valid via parseValue(),\n    // which can throw to indicate failure. If it throws, maintain a reference\n    // to the original error.\n\n    try {\n      parseResult = type.parseValue(inputValue);\n    } catch (error) {\n      if (error instanceof GraphQLError) {\n        onError(pathToArray(path), inputValue, error);\n      } else {\n        onError(\n          pathToArray(path),\n          inputValue,\n          new GraphQLError(\n            `Expected type \"${type.name}\". ` + error.message,\n            undefined,\n            undefined,\n            undefined,\n            undefined,\n            error,\n          ),\n        );\n      }\n\n      return;\n    }\n\n    if (parseResult === undefined) {\n      onError(\n        pathToArray(path),\n        inputValue,\n        new GraphQLError(`Expected type \"${type.name}\".`),\n      );\n    }\n\n    return parseResult;\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n  false || invariant(false, 'Unexpected input type: ' + inspect(type));\n}\n"]},"metadata":{},"sourceType":"module"}