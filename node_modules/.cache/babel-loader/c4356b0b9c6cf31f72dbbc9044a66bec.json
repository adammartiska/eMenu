{"ast":null,"code":"import { keyMap } from '../jsutils/keyMap.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { naturalCompare } from '../jsutils/naturalCompare.mjs';\nimport { print } from '../language/printer.mjs';\nimport { visit } from '../language/visitor.mjs';\nimport { isSpecifiedScalarType } from '../type/scalars.mjs';\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNonNullType, isListType, isNamedType, isRequiredArgument, isRequiredInputField } from '../type/definition.mjs';\nimport { astFromValue } from './astFromValue.mjs';\nexport let BreakingChangeType;\n\n(function (BreakingChangeType) {\n  BreakingChangeType['TYPE_REMOVED'] = 'TYPE_REMOVED';\n  BreakingChangeType['TYPE_CHANGED_KIND'] = 'TYPE_CHANGED_KIND';\n  BreakingChangeType['TYPE_REMOVED_FROM_UNION'] = 'TYPE_REMOVED_FROM_UNION';\n  BreakingChangeType['VALUE_REMOVED_FROM_ENUM'] = 'VALUE_REMOVED_FROM_ENUM';\n  BreakingChangeType['REQUIRED_INPUT_FIELD_ADDED'] = 'REQUIRED_INPUT_FIELD_ADDED';\n  BreakingChangeType['IMPLEMENTED_INTERFACE_REMOVED'] = 'IMPLEMENTED_INTERFACE_REMOVED';\n  BreakingChangeType['FIELD_REMOVED'] = 'FIELD_REMOVED';\n  BreakingChangeType['FIELD_CHANGED_KIND'] = 'FIELD_CHANGED_KIND';\n  BreakingChangeType['REQUIRED_ARG_ADDED'] = 'REQUIRED_ARG_ADDED';\n  BreakingChangeType['ARG_REMOVED'] = 'ARG_REMOVED';\n  BreakingChangeType['ARG_CHANGED_KIND'] = 'ARG_CHANGED_KIND';\n  BreakingChangeType['DIRECTIVE_REMOVED'] = 'DIRECTIVE_REMOVED';\n  BreakingChangeType['DIRECTIVE_ARG_REMOVED'] = 'DIRECTIVE_ARG_REMOVED';\n  BreakingChangeType['REQUIRED_DIRECTIVE_ARG_ADDED'] = 'REQUIRED_DIRECTIVE_ARG_ADDED';\n  BreakingChangeType['DIRECTIVE_REPEATABLE_REMOVED'] = 'DIRECTIVE_REPEATABLE_REMOVED';\n  BreakingChangeType['DIRECTIVE_LOCATION_REMOVED'] = 'DIRECTIVE_LOCATION_REMOVED';\n})(BreakingChangeType || (BreakingChangeType = {}));\n\nexport let DangerousChangeType;\n\n(function (DangerousChangeType) {\n  DangerousChangeType['VALUE_ADDED_TO_ENUM'] = 'VALUE_ADDED_TO_ENUM';\n  DangerousChangeType['TYPE_ADDED_TO_UNION'] = 'TYPE_ADDED_TO_UNION';\n  DangerousChangeType['OPTIONAL_INPUT_FIELD_ADDED'] = 'OPTIONAL_INPUT_FIELD_ADDED';\n  DangerousChangeType['OPTIONAL_ARG_ADDED'] = 'OPTIONAL_ARG_ADDED';\n  DangerousChangeType['IMPLEMENTED_INTERFACE_ADDED'] = 'IMPLEMENTED_INTERFACE_ADDED';\n  DangerousChangeType['ARG_DEFAULT_VALUE_CHANGE'] = 'ARG_DEFAULT_VALUE_CHANGE';\n})(DangerousChangeType || (DangerousChangeType = {}));\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of breaking changes covered by the other functions down below.\n */\n\n\nexport function findBreakingChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(change => change.type in BreakingChangeType);\n}\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of potentially dangerous changes covered by the other functions down below.\n */\n\nexport function findDangerousChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(change => change.type in DangerousChangeType);\n}\n\nfunction findSchemaChanges(oldSchema, newSchema) {\n  return [...findTypeChanges(oldSchema, newSchema), ...findDirectiveChanges(oldSchema, newSchema)];\n}\n\nfunction findDirectiveChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const directivesDiff = diff(oldSchema.getDirectives(), newSchema.getDirectives());\n\n  for (const oldDirective of directivesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.DIRECTIVE_REMOVED,\n      description: `${oldDirective.name} was removed.`\n    });\n  }\n\n  for (const [oldDirective, newDirective] of directivesDiff.persisted) {\n    const argsDiff = diff(oldDirective.args, newDirective.args);\n\n    for (const newArg of argsDiff.added) {\n      if (isRequiredArgument(newArg)) {\n        schemaChanges.push({\n          type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,\n          description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`\n        });\n      }\n    }\n\n    for (const oldArg of argsDiff.removed) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n        description: `${oldArg.name} was removed from ${oldDirective.name}.`\n      });\n    }\n\n    if (oldDirective.isRepeatable && !newDirective.isRepeatable) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,\n        description: `Repeatable flag was removed from ${oldDirective.name}.`\n      });\n    }\n\n    for (const location of oldDirective.locations) {\n      if (!newDirective.locations.includes(location)) {\n        schemaChanges.push({\n          type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n          description: `${location} was removed from ${oldDirective.name}.`\n        });\n      }\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findTypeChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const typesDiff = diff(Object.values(oldSchema.getTypeMap()), Object.values(newSchema.getTypeMap()));\n\n  for (const oldType of typesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED,\n      description: isSpecifiedScalarType(oldType) ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.` : `${oldType.name} was removed.`\n    });\n  }\n\n  for (const [oldType, newType] of typesDiff.persisted) {\n    if (isEnumType(oldType) && isEnumType(newType)) {\n      schemaChanges.push(...findEnumTypeChanges(oldType, newType));\n    } else if (isUnionType(oldType) && isUnionType(newType)) {\n      schemaChanges.push(...findUnionTypeChanges(oldType, newType));\n    } else if (isInputObjectType(oldType) && isInputObjectType(newType)) {\n      schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));\n    } else if (isObjectType(oldType) && isObjectType(newType)) {\n      schemaChanges.push(...findFieldChanges(oldType, newType), ...findImplementedInterfacesChanges(oldType, newType));\n    } else if (isInterfaceType(oldType) && isInterfaceType(newType)) {\n      schemaChanges.push(...findFieldChanges(oldType, newType), ...findImplementedInterfacesChanges(oldType, newType));\n    } else if (oldType.constructor !== newType.constructor) {\n      schemaChanges.push({\n        type: BreakingChangeType.TYPE_CHANGED_KIND,\n        description: `${oldType.name} changed from ` + `${typeKindName(oldType)} to ${typeKindName(newType)}.`\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findInputObjectTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(Object.values(oldType.getFields()), Object.values(newType.getFields()));\n\n  for (const newField of fieldsDiff.added) {\n    if (isRequiredInputField(newField)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,\n        description: `A required field ${newField.name} on input type ${oldType.name} was added.`\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,\n        description: `An optional field ${newField.name} on input type ${oldType.name} was added.`\n      });\n    }\n  }\n\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: `${oldType.name}.${oldField.name} was removed.`\n    });\n  }\n\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldField.type, newField.type);\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description: `${oldType.name}.${oldField.name} changed type from ` + `${String(oldField.type)} to ${String(newField.type)}.`\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findUnionTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());\n\n  for (const newPossibleType of possibleTypesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n      description: `${newPossibleType.name} was added to union type ${oldType.name}.`\n    });\n  }\n\n  for (const oldPossibleType of possibleTypesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n      description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findEnumTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const valuesDiff = diff(oldType.getValues(), newType.getValues());\n\n  for (const newValue of valuesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n      description: `${newValue.name} was added to enum type ${oldType.name}.`\n    });\n  }\n\n  for (const oldValue of valuesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n      description: `${oldValue.name} was removed from enum type ${oldType.name}.`\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findImplementedInterfacesChanges(oldType, newType) {\n  const schemaChanges = [];\n  const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());\n\n  for (const newInterface of interfacesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,\n      description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`\n    });\n  }\n\n  for (const oldInterface of interfacesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,\n      description: `${oldType.name} no longer implements interface ${oldInterface.name}.`\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findFieldChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(Object.values(oldType.getFields()), Object.values(newType.getFields()));\n\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: `${oldType.name}.${oldField.name} was removed.`\n    });\n  }\n\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    schemaChanges.push(...findArgChanges(oldType, oldField, newField));\n    const isSafe = isChangeSafeForObjectOrInterfaceField(oldField.type, newField.type);\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description: `${oldType.name}.${oldField.name} changed type from ` + `${String(oldField.type)} to ${String(newField.type)}.`\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findArgChanges(oldType, oldField, newField) {\n  const schemaChanges = [];\n  const argsDiff = diff(oldField.args, newField.args);\n\n  for (const oldArg of argsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.ARG_REMOVED,\n      description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`\n    });\n  }\n\n  for (const [oldArg, newArg] of argsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldArg.type, newArg.type);\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.ARG_CHANGED_KIND,\n        description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ` + `${String(oldArg.type)} to ${String(newArg.type)}.`\n      });\n    } else if (oldArg.defaultValue !== undefined) {\n      if (newArg.defaultValue === undefined) {\n        schemaChanges.push({\n          type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n          description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`\n        });\n      } else {\n        // Since we looking only for client's observable changes we should\n        // compare default values in the same representation as they are\n        // represented inside introspection.\n        const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);\n        const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);\n\n        if (oldValueStr !== newValueStr) {\n          schemaChanges.push({\n            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`\n          });\n        }\n      }\n    }\n  }\n\n  for (const newArg of argsDiff.added) {\n    if (isRequiredArgument(newArg)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_ARG_ADDED,\n        description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_ARG_ADDED,\n        description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if (isListType(oldType)) {\n    return (// if they're both lists, make sure the underlying types are compatible\n      isListType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) || // moving from nullable to non-null of the same underlying type is safe\n      isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n    );\n  }\n\n  if (isNonNullType(oldType)) {\n    // if they're both non-null, make sure the underlying types are compatible\n    return isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);\n  }\n\n  return (// if they're both named types, see if their names are equivalent\n    isNamedType(newType) && oldType.name === newType.name || // moving from nullable to non-null of the same underlying type is safe\n    isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n  );\n}\n\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if (isListType(oldType)) {\n    // if they're both lists, make sure the underlying types are compatible\n    return isListType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);\n  }\n\n  if (isNonNullType(oldType)) {\n    return (// if they're both non-null, make sure the underlying types are\n      // compatible\n      isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) || // moving from non-null to nullable of the same underlying type is safe\n      !isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)\n    );\n  } // if they're both named types, see if their names are equivalent\n\n\n  return isNamedType(newType) && oldType.name === newType.name;\n}\n\nfunction typeKindName(type) {\n  if (isScalarType(type)) {\n    return 'a Scalar type';\n  }\n\n  if (isObjectType(type)) {\n    return 'an Object type';\n  }\n\n  if (isInterfaceType(type)) {\n    return 'an Interface type';\n  }\n\n  if (isUnionType(type)) {\n    return 'a Union type';\n  }\n\n  if (isEnumType(type)) {\n    return 'an Enum type';\n  }\n\n  if (isInputObjectType(type)) {\n    return 'an Input type';\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\n}\n\nfunction stringifyValue(value, type) {\n  const ast = astFromValue(value, type);\n  ast != null || invariant(false);\n  const sortedAST = visit(ast, {\n    ObjectValue(objectNode) {\n      // Make a copy since sort mutates array\n      const fields = [...objectNode.fields];\n      fields.sort((fieldA, fieldB) => naturalCompare(fieldA.name.value, fieldB.name.value));\n      return { ...objectNode,\n        fields\n      };\n    }\n\n  });\n  return print(sortedAST);\n}\n\nfunction diff(oldArray, newArray) {\n  const added = [];\n  const removed = [];\n  const persisted = [];\n  const oldMap = keyMap(oldArray, _ref => {\n    let {\n      name\n    } = _ref;\n    return name;\n  });\n  const newMap = keyMap(newArray, _ref2 => {\n    let {\n      name\n    } = _ref2;\n    return name;\n  });\n\n  for (const oldItem of oldArray) {\n    const newItem = newMap[oldItem.name];\n\n    if (newItem === undefined) {\n      removed.push(oldItem);\n    } else {\n      persisted.push([oldItem, newItem]);\n    }\n  }\n\n  for (const newItem of newArray) {\n    if (oldMap[newItem.name] === undefined) {\n      added.push(newItem);\n    }\n  }\n\n  return {\n    added,\n    persisted,\n    removed\n  };\n}","map":{"version":3,"sources":["/Users/adammartiska/Projects/eMenu/GUI/eMenu-customer/node_modules/graphql/utilities/findBreakingChanges.mjs"],"names":["keyMap","inspect","invariant","naturalCompare","print","visit","isSpecifiedScalarType","isScalarType","isObjectType","isInterfaceType","isUnionType","isEnumType","isInputObjectType","isNonNullType","isListType","isNamedType","isRequiredArgument","isRequiredInputField","astFromValue","BreakingChangeType","DangerousChangeType","findBreakingChanges","oldSchema","newSchema","findSchemaChanges","filter","change","type","findDangerousChanges","findTypeChanges","findDirectiveChanges","schemaChanges","directivesDiff","diff","getDirectives","oldDirective","removed","push","DIRECTIVE_REMOVED","description","name","newDirective","persisted","argsDiff","args","newArg","added","REQUIRED_DIRECTIVE_ARG_ADDED","oldArg","DIRECTIVE_ARG_REMOVED","isRepeatable","DIRECTIVE_REPEATABLE_REMOVED","location","locations","includes","DIRECTIVE_LOCATION_REMOVED","typesDiff","Object","values","getTypeMap","oldType","TYPE_REMOVED","newType","findEnumTypeChanges","findUnionTypeChanges","findInputObjectTypeChanges","findFieldChanges","findImplementedInterfacesChanges","constructor","TYPE_CHANGED_KIND","typeKindName","fieldsDiff","getFields","newField","REQUIRED_INPUT_FIELD_ADDED","OPTIONAL_INPUT_FIELD_ADDED","oldField","FIELD_REMOVED","isSafe","isChangeSafeForInputObjectFieldOrFieldArg","FIELD_CHANGED_KIND","String","possibleTypesDiff","getTypes","newPossibleType","TYPE_ADDED_TO_UNION","oldPossibleType","TYPE_REMOVED_FROM_UNION","valuesDiff","getValues","newValue","VALUE_ADDED_TO_ENUM","oldValue","VALUE_REMOVED_FROM_ENUM","interfacesDiff","getInterfaces","newInterface","IMPLEMENTED_INTERFACE_ADDED","oldInterface","IMPLEMENTED_INTERFACE_REMOVED","findArgChanges","isChangeSafeForObjectOrInterfaceField","ARG_REMOVED","ARG_CHANGED_KIND","defaultValue","undefined","ARG_DEFAULT_VALUE_CHANGE","oldValueStr","stringifyValue","newValueStr","REQUIRED_ARG_ADDED","OPTIONAL_ARG_ADDED","ofType","value","ast","sortedAST","ObjectValue","objectNode","fields","sort","fieldA","fieldB","oldArray","newArray","oldMap","newMap","oldItem","newItem"],"mappings":"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","sourcesContent":["import { keyMap } from '../jsutils/keyMap.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { naturalCompare } from '../jsutils/naturalCompare.mjs';\nimport { print } from '../language/printer.mjs';\nimport { visit } from '../language/visitor.mjs';\nimport { isSpecifiedScalarType } from '../type/scalars.mjs';\nimport {\n  isScalarType,\n  isObjectType,\n  isInterfaceType,\n  isUnionType,\n  isEnumType,\n  isInputObjectType,\n  isNonNullType,\n  isListType,\n  isNamedType,\n  isRequiredArgument,\n  isRequiredInputField,\n} from '../type/definition.mjs';\nimport { astFromValue } from './astFromValue.mjs';\nexport let BreakingChangeType;\n\n(function (BreakingChangeType) {\n  BreakingChangeType['TYPE_REMOVED'] = 'TYPE_REMOVED';\n  BreakingChangeType['TYPE_CHANGED_KIND'] = 'TYPE_CHANGED_KIND';\n  BreakingChangeType['TYPE_REMOVED_FROM_UNION'] = 'TYPE_REMOVED_FROM_UNION';\n  BreakingChangeType['VALUE_REMOVED_FROM_ENUM'] = 'VALUE_REMOVED_FROM_ENUM';\n  BreakingChangeType['REQUIRED_INPUT_FIELD_ADDED'] =\n    'REQUIRED_INPUT_FIELD_ADDED';\n  BreakingChangeType['IMPLEMENTED_INTERFACE_REMOVED'] =\n    'IMPLEMENTED_INTERFACE_REMOVED';\n  BreakingChangeType['FIELD_REMOVED'] = 'FIELD_REMOVED';\n  BreakingChangeType['FIELD_CHANGED_KIND'] = 'FIELD_CHANGED_KIND';\n  BreakingChangeType['REQUIRED_ARG_ADDED'] = 'REQUIRED_ARG_ADDED';\n  BreakingChangeType['ARG_REMOVED'] = 'ARG_REMOVED';\n  BreakingChangeType['ARG_CHANGED_KIND'] = 'ARG_CHANGED_KIND';\n  BreakingChangeType['DIRECTIVE_REMOVED'] = 'DIRECTIVE_REMOVED';\n  BreakingChangeType['DIRECTIVE_ARG_REMOVED'] = 'DIRECTIVE_ARG_REMOVED';\n  BreakingChangeType['REQUIRED_DIRECTIVE_ARG_ADDED'] =\n    'REQUIRED_DIRECTIVE_ARG_ADDED';\n  BreakingChangeType['DIRECTIVE_REPEATABLE_REMOVED'] =\n    'DIRECTIVE_REPEATABLE_REMOVED';\n  BreakingChangeType['DIRECTIVE_LOCATION_REMOVED'] =\n    'DIRECTIVE_LOCATION_REMOVED';\n})(BreakingChangeType || (BreakingChangeType = {}));\n\nexport let DangerousChangeType;\n\n(function (DangerousChangeType) {\n  DangerousChangeType['VALUE_ADDED_TO_ENUM'] = 'VALUE_ADDED_TO_ENUM';\n  DangerousChangeType['TYPE_ADDED_TO_UNION'] = 'TYPE_ADDED_TO_UNION';\n  DangerousChangeType['OPTIONAL_INPUT_FIELD_ADDED'] =\n    'OPTIONAL_INPUT_FIELD_ADDED';\n  DangerousChangeType['OPTIONAL_ARG_ADDED'] = 'OPTIONAL_ARG_ADDED';\n  DangerousChangeType['IMPLEMENTED_INTERFACE_ADDED'] =\n    'IMPLEMENTED_INTERFACE_ADDED';\n  DangerousChangeType['ARG_DEFAULT_VALUE_CHANGE'] = 'ARG_DEFAULT_VALUE_CHANGE';\n})(DangerousChangeType || (DangerousChangeType = {}));\n\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of breaking changes covered by the other functions down below.\n */\nexport function findBreakingChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(\n    (change) => change.type in BreakingChangeType,\n  );\n}\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of potentially dangerous changes covered by the other functions down below.\n */\n\nexport function findDangerousChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(\n    (change) => change.type in DangerousChangeType,\n  );\n}\n\nfunction findSchemaChanges(oldSchema, newSchema) {\n  return [\n    ...findTypeChanges(oldSchema, newSchema),\n    ...findDirectiveChanges(oldSchema, newSchema),\n  ];\n}\n\nfunction findDirectiveChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const directivesDiff = diff(\n    oldSchema.getDirectives(),\n    newSchema.getDirectives(),\n  );\n\n  for (const oldDirective of directivesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.DIRECTIVE_REMOVED,\n      description: `${oldDirective.name} was removed.`,\n    });\n  }\n\n  for (const [oldDirective, newDirective] of directivesDiff.persisted) {\n    const argsDiff = diff(oldDirective.args, newDirective.args);\n\n    for (const newArg of argsDiff.added) {\n      if (isRequiredArgument(newArg)) {\n        schemaChanges.push({\n          type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,\n          description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`,\n        });\n      }\n    }\n\n    for (const oldArg of argsDiff.removed) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n        description: `${oldArg.name} was removed from ${oldDirective.name}.`,\n      });\n    }\n\n    if (oldDirective.isRepeatable && !newDirective.isRepeatable) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,\n        description: `Repeatable flag was removed from ${oldDirective.name}.`,\n      });\n    }\n\n    for (const location of oldDirective.locations) {\n      if (!newDirective.locations.includes(location)) {\n        schemaChanges.push({\n          type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n          description: `${location} was removed from ${oldDirective.name}.`,\n        });\n      }\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findTypeChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const typesDiff = diff(\n    Object.values(oldSchema.getTypeMap()),\n    Object.values(newSchema.getTypeMap()),\n  );\n\n  for (const oldType of typesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED,\n      description: isSpecifiedScalarType(oldType)\n        ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.`\n        : `${oldType.name} was removed.`,\n    });\n  }\n\n  for (const [oldType, newType] of typesDiff.persisted) {\n    if (isEnumType(oldType) && isEnumType(newType)) {\n      schemaChanges.push(...findEnumTypeChanges(oldType, newType));\n    } else if (isUnionType(oldType) && isUnionType(newType)) {\n      schemaChanges.push(...findUnionTypeChanges(oldType, newType));\n    } else if (isInputObjectType(oldType) && isInputObjectType(newType)) {\n      schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));\n    } else if (isObjectType(oldType) && isObjectType(newType)) {\n      schemaChanges.push(\n        ...findFieldChanges(oldType, newType),\n        ...findImplementedInterfacesChanges(oldType, newType),\n      );\n    } else if (isInterfaceType(oldType) && isInterfaceType(newType)) {\n      schemaChanges.push(\n        ...findFieldChanges(oldType, newType),\n        ...findImplementedInterfacesChanges(oldType, newType),\n      );\n    } else if (oldType.constructor !== newType.constructor) {\n      schemaChanges.push({\n        type: BreakingChangeType.TYPE_CHANGED_KIND,\n        description:\n          `${oldType.name} changed from ` +\n          `${typeKindName(oldType)} to ${typeKindName(newType)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findInputObjectTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(\n    Object.values(oldType.getFields()),\n    Object.values(newType.getFields()),\n  );\n\n  for (const newField of fieldsDiff.added) {\n    if (isRequiredInputField(newField)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,\n        description: `A required field ${newField.name} on input type ${oldType.name} was added.`,\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,\n        description: `An optional field ${newField.name} on input type ${oldType.name} was added.`,\n      });\n    }\n  }\n\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: `${oldType.name}.${oldField.name} was removed.`,\n    });\n  }\n\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(\n      oldField.type,\n      newField.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} changed type from ` +\n          `${String(oldField.type)} to ${String(newField.type)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findUnionTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());\n\n  for (const newPossibleType of possibleTypesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n      description: `${newPossibleType.name} was added to union type ${oldType.name}.`,\n    });\n  }\n\n  for (const oldPossibleType of possibleTypesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n      description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findEnumTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const valuesDiff = diff(oldType.getValues(), newType.getValues());\n\n  for (const newValue of valuesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n      description: `${newValue.name} was added to enum type ${oldType.name}.`,\n    });\n  }\n\n  for (const oldValue of valuesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n      description: `${oldValue.name} was removed from enum type ${oldType.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findImplementedInterfacesChanges(oldType, newType) {\n  const schemaChanges = [];\n  const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());\n\n  for (const newInterface of interfacesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,\n      description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`,\n    });\n  }\n\n  for (const oldInterface of interfacesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,\n      description: `${oldType.name} no longer implements interface ${oldInterface.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findFieldChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(\n    Object.values(oldType.getFields()),\n    Object.values(newType.getFields()),\n  );\n\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: `${oldType.name}.${oldField.name} was removed.`,\n    });\n  }\n\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    schemaChanges.push(...findArgChanges(oldType, oldField, newField));\n    const isSafe = isChangeSafeForObjectOrInterfaceField(\n      oldField.type,\n      newField.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} changed type from ` +\n          `${String(oldField.type)} to ${String(newField.type)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findArgChanges(oldType, oldField, newField) {\n  const schemaChanges = [];\n  const argsDiff = diff(oldField.args, newField.args);\n\n  for (const oldArg of argsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.ARG_REMOVED,\n      description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`,\n    });\n  }\n\n  for (const [oldArg, newArg] of argsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(\n      oldArg.type,\n      newArg.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.ARG_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ` +\n          `${String(oldArg.type)} to ${String(newArg.type)}.`,\n      });\n    } else if (oldArg.defaultValue !== undefined) {\n      if (newArg.defaultValue === undefined) {\n        schemaChanges.push({\n          type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n          description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`,\n        });\n      } else {\n        // Since we looking only for client's observable changes we should\n        // compare default values in the same representation as they are\n        // represented inside introspection.\n        const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);\n        const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);\n\n        if (oldValueStr !== newValueStr) {\n          schemaChanges.push({\n            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`,\n          });\n        }\n      }\n    }\n  }\n\n  for (const newArg of argsDiff.added) {\n    if (isRequiredArgument(newArg)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_ARG_ADDED,\n        description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`,\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_ARG_ADDED,\n        description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if (isListType(oldType)) {\n    return (\n      // if they're both lists, make sure the underlying types are compatible\n      (isListType(newType) &&\n        isChangeSafeForObjectOrInterfaceField(\n          oldType.ofType,\n          newType.ofType,\n        )) || // moving from nullable to non-null of the same underlying type is safe\n      (isNonNullType(newType) &&\n        isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType))\n    );\n  }\n\n  if (isNonNullType(oldType)) {\n    // if they're both non-null, make sure the underlying types are compatible\n    return (\n      isNonNullType(newType) &&\n      isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType)\n    );\n  }\n\n  return (\n    // if they're both named types, see if their names are equivalent\n    (isNamedType(newType) && oldType.name === newType.name) || // moving from nullable to non-null of the same underlying type is safe\n    (isNonNullType(newType) &&\n      isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType))\n  );\n}\n\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if (isListType(oldType)) {\n    // if they're both lists, make sure the underlying types are compatible\n    return (\n      isListType(newType) &&\n      isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType)\n    );\n  }\n\n  if (isNonNullType(oldType)) {\n    return (\n      // if they're both non-null, make sure the underlying types are\n      // compatible\n      (isNonNullType(newType) &&\n        isChangeSafeForInputObjectFieldOrFieldArg(\n          oldType.ofType,\n          newType.ofType,\n        )) || // moving from non-null to nullable of the same underlying type is safe\n      (!isNonNullType(newType) &&\n        isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType))\n    );\n  } // if they're both named types, see if their names are equivalent\n\n  return isNamedType(newType) && oldType.name === newType.name;\n}\n\nfunction typeKindName(type) {\n  if (isScalarType(type)) {\n    return 'a Scalar type';\n  }\n\n  if (isObjectType(type)) {\n    return 'an Object type';\n  }\n\n  if (isInterfaceType(type)) {\n    return 'an Interface type';\n  }\n\n  if (isUnionType(type)) {\n    return 'a Union type';\n  }\n\n  if (isEnumType(type)) {\n    return 'an Enum type';\n  }\n\n  if (isInputObjectType(type)) {\n    return 'an Input type';\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\n}\n\nfunction stringifyValue(value, type) {\n  const ast = astFromValue(value, type);\n  ast != null || invariant(false);\n  const sortedAST = visit(ast, {\n    ObjectValue(objectNode) {\n      // Make a copy since sort mutates array\n      const fields = [...objectNode.fields];\n      fields.sort((fieldA, fieldB) =>\n        naturalCompare(fieldA.name.value, fieldB.name.value),\n      );\n      return { ...objectNode, fields };\n    },\n  });\n  return print(sortedAST);\n}\n\nfunction diff(oldArray, newArray) {\n  const added = [];\n  const removed = [];\n  const persisted = [];\n  const oldMap = keyMap(oldArray, ({ name }) => name);\n  const newMap = keyMap(newArray, ({ name }) => name);\n\n  for (const oldItem of oldArray) {\n    const newItem = newMap[oldItem.name];\n\n    if (newItem === undefined) {\n      removed.push(oldItem);\n    } else {\n      persisted.push([oldItem, newItem]);\n    }\n  }\n\n  for (const newItem of newArray) {\n    if (oldMap[newItem.name] === undefined) {\n      added.push(newItem);\n    }\n  }\n\n  return {\n    added,\n    persisted,\n    removed,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}