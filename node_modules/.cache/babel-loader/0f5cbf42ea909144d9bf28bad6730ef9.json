{"ast":null,"code":"import { keyMap } from '../jsutils/keyMap.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { mapValue } from '../jsutils/mapValue.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { devAssert } from '../jsutils/devAssert.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { isTypeDefinitionNode, isTypeExtensionNode } from '../language/predicates.mjs';\nimport { assertValidSDLExtension } from '../validation/validate.mjs';\nimport { getDirectiveValues } from '../execution/values.mjs';\nimport { assertSchema, GraphQLSchema } from '../type/schema.mjs';\nimport { specifiedScalarTypes, isSpecifiedScalarType } from '../type/scalars.mjs';\nimport { introspectionTypes, isIntrospectionType } from '../type/introspection.mjs';\nimport { GraphQLDirective, GraphQLDeprecatedDirective, GraphQLSpecifiedByDirective } from '../type/directives.mjs';\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isListType, isNonNullType, isEnumType, isInputObjectType, GraphQLList, GraphQLNonNull, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType } from '../type/definition.mjs';\nimport { valueFromAST } from './valueFromAST.mjs';\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n */\n\nexport function extendSchema(schema, documentAST, options) {\n  assertSchema(schema);\n  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(false, 'Must provide valid Document AST.');\n\n  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {\n    assertValidSDLExtension(documentAST, schema);\n  }\n\n  const schemaConfig = schema.toConfig();\n  const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);\n  return schemaConfig === extendedConfig ? schema : new GraphQLSchema(extendedConfig);\n}\n/**\n * @internal\n */\n\nexport function extendSchemaImpl(schemaConfig, documentAST, options) {\n  var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid; // Collect the type definitions and extensions found in the document.\n\n\n  const typeDefs = [];\n  const typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  const directiveDefs = [];\n  let schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  const schemaExtensions = [];\n\n  for (const def of documentAST.definitions) {\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (def.kind === Kind.SCHEMA_EXTENSION) {\n      schemaExtensions.push(def);\n    } else if (isTypeDefinitionNode(def)) {\n      typeDefs.push(def);\n    } else if (isTypeExtensionNode(def)) {\n      const extendedTypeName = def.name.value;\n      const existingTypeExtensions = typeExtensionsMap[extendedTypeName];\n      typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n\n  if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {\n    return schemaConfig;\n  }\n\n  const typeMap = Object.create(null);\n\n  for (const existingType of schemaConfig.types) {\n    typeMap[existingType.name] = extendNamedType(existingType);\n  }\n\n  for (const typeNode of typeDefs) {\n    var _stdTypeMap$name;\n\n    const name = typeNode.name.value;\n    typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);\n  }\n\n  const operationTypes = {\n    // Get the extended root operation types.\n    query: schemaConfig.query && replaceNamedType(schemaConfig.query),\n    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),\n    subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),\n    // Then, incorporate schema definition and all schema extensions.\n    ...(schemaDef && getOperationTypes([schemaDef])),\n    ...getOperationTypes(schemaExtensions)\n  }; // Then produce and return a Schema config with these types.\n\n  return {\n    description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value,\n    ...operationTypes,\n    types: Object.values(typeMap),\n    directives: [...schemaConfig.directives.map(replaceDirective), ...directiveDefs.map(buildDirective)],\n    extensions: Object.create(null),\n    astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,\n    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),\n    assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false\n  }; // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function replaceType(type) {\n    if (isListType(type)) {\n      // @ts-expect-error\n      return new GraphQLList(replaceType(type.ofType));\n    }\n\n    if (isNonNullType(type)) {\n      // @ts-expect-error\n      return new GraphQLNonNull(replaceType(type.ofType));\n    } // @ts-expect-error FIXME\n\n\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType(type) {\n    // Note: While this could make early assertions to get the correctly\n    // typed values, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    return typeMap[type.name];\n  }\n\n  function replaceDirective(directive) {\n    const config = directive.toConfig();\n    return new GraphQLDirective({ ...config,\n      args: mapValue(config.args, extendArg)\n    });\n  }\n\n  function extendNamedType(type) {\n    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {\n      // Builtin types are not extended.\n      return type;\n    }\n\n    if (isScalarType(type)) {\n      return extendScalarType(type);\n    }\n\n    if (isObjectType(type)) {\n      return extendObjectType(type);\n    }\n\n    if (isInterfaceType(type)) {\n      return extendInterfaceType(type);\n    }\n\n    if (isUnionType(type)) {\n      return extendUnionType(type);\n    }\n\n    if (isEnumType(type)) {\n      return extendEnumType(type);\n    } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n    if (isInputObjectType(type)) {\n      return extendInputObjectType(type);\n    } // istanbul ignore next (Not reachable. All possible types have been considered)\n\n\n    false || invariant(false, 'Unexpected type: ' + inspect(type));\n  }\n\n  function extendInputObjectType(type) {\n    var _typeExtensionsMap$co;\n\n    const config = type.toConfig();\n    const extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];\n    return new GraphQLInputObjectType({ ...config,\n      fields: () => ({ ...mapValue(config.fields, field => ({ ...field,\n          type: replaceType(field.type)\n        })),\n        ...buildInputFieldMap(extensions)\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    });\n  }\n\n  function extendEnumType(type) {\n    var _typeExtensionsMap$ty;\n\n    const config = type.toConfig();\n    const extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];\n    return new GraphQLEnumType({ ...config,\n      values: { ...config.values,\n        ...buildEnumValueMap(extensions)\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    });\n  }\n\n  function extendScalarType(type) {\n    var _typeExtensionsMap$co2;\n\n    const config = type.toConfig();\n    const extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];\n    let specifiedByURL = config.specifiedByURL;\n\n    for (const extensionNode of extensions) {\n      var _getSpecifiedByURL;\n\n      specifiedByURL = (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null && _getSpecifiedByURL !== void 0 ? _getSpecifiedByURL : specifiedByURL;\n    }\n\n    return new GraphQLScalarType({ ...config,\n      specifiedByURL,\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    });\n  }\n\n  function extendObjectType(type) {\n    var _typeExtensionsMap$co3;\n\n    const config = type.toConfig();\n    const extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];\n    return new GraphQLObjectType({ ...config,\n      interfaces: () => [...type.getInterfaces().map(replaceNamedType), ...buildInterfaces(extensions)],\n      fields: () => ({ ...mapValue(config.fields, extendField),\n        ...buildFieldMap(extensions)\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    });\n  }\n\n  function extendInterfaceType(type) {\n    var _typeExtensionsMap$co4;\n\n    const config = type.toConfig();\n    const extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];\n    return new GraphQLInterfaceType({ ...config,\n      interfaces: () => [...type.getInterfaces().map(replaceNamedType), ...buildInterfaces(extensions)],\n      fields: () => ({ ...mapValue(config.fields, extendField),\n        ...buildFieldMap(extensions)\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    });\n  }\n\n  function extendUnionType(type) {\n    var _typeExtensionsMap$co5;\n\n    const config = type.toConfig();\n    const extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];\n    return new GraphQLUnionType({ ...config,\n      types: () => [...type.getTypes().map(replaceNamedType), ...buildUnionTypes(extensions)],\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    });\n  }\n\n  function extendField(field) {\n    return { ...field,\n      type: replaceType(field.type),\n      args: field.args && mapValue(field.args, extendArg)\n    };\n  }\n\n  function extendArg(arg) {\n    return { ...arg,\n      type: replaceType(arg.type)\n    };\n  }\n\n  function getOperationTypes(nodes) {\n    const opTypes = {};\n\n    for (const node of nodes) {\n      var _node$operationTypes; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n\n      const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];\n\n      for (const operationType of operationTypesNodes) {\n        // Note: While this could make early assertions to get the correctly\n        // typed values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n        // @ts-expect-error\n        opTypes[operationType.operation] = getNamedType(operationType.type);\n      }\n    }\n\n    return opTypes;\n  }\n\n  function getNamedType(node) {\n    var _stdTypeMap$name2;\n\n    const name = node.name.value;\n    const type = (_stdTypeMap$name2 = stdTypeMap[name]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name];\n\n    if (type === undefined) {\n      throw new Error(`Unknown type: \"${name}\".`);\n    }\n\n    return type;\n  }\n\n  function getWrappedType(node) {\n    if (node.kind === Kind.LIST_TYPE) {\n      return new GraphQLList(getWrappedType(node.type));\n    }\n\n    if (node.kind === Kind.NON_NULL_TYPE) {\n      return new GraphQLNonNull(getWrappedType(node.type));\n    }\n\n    return getNamedType(node);\n  }\n\n  function buildDirective(node) {\n    var _node$description;\n\n    return new GraphQLDirective({\n      name: node.name.value,\n      description: (_node$description = node.description) === null || _node$description === void 0 ? void 0 : _node$description.value,\n      // @ts-expect-error\n      locations: node.locations.map(({\n        value\n      }) => value),\n      isRepeatable: node.repeatable,\n      args: buildArgumentMap(node.arguments),\n      astNode: node\n    });\n  }\n\n  function buildFieldMap(nodes) {\n    const fieldConfigMap = Object.create(null);\n\n    for (const node of nodes) {\n      var _node$fields; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n\n      const nodeFields = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];\n\n      for (const field of nodeFields) {\n        var _field$description;\n\n        fieldConfigMap[field.name.value] = {\n          // Note: While this could make assertions to get the correctly typed\n          // value, that would throw immediately while type system validation\n          // with validateSchema() will produce more actionable results.\n          type: getWrappedType(field.type),\n          description: (_field$description = field.description) === null || _field$description === void 0 ? void 0 : _field$description.value,\n          args: buildArgumentMap(field.arguments),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field\n        };\n      }\n    }\n\n    return fieldConfigMap;\n  }\n\n  function buildArgumentMap(args) {\n    // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n    const argsNodes = args !== null && args !== void 0 ? args : [];\n    const argConfigMap = Object.create(null);\n\n    for (const arg of argsNodes) {\n      var _arg$description; // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n\n\n      const type = getWrappedType(arg.type);\n      argConfigMap[arg.name.value] = {\n        type,\n        description: (_arg$description = arg.description) === null || _arg$description === void 0 ? void 0 : _arg$description.value,\n        defaultValue: valueFromAST(arg.defaultValue, type),\n        deprecationReason: getDeprecationReason(arg),\n        astNode: arg\n      };\n    }\n\n    return argConfigMap;\n  }\n\n  function buildInputFieldMap(nodes) {\n    const inputFieldMap = Object.create(null);\n\n    for (const node of nodes) {\n      var _node$fields2; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n\n      const fieldsNodes = (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : [];\n\n      for (const field of fieldsNodes) {\n        var _field$description2; // Note: While this could make assertions to get the correctly typed\n        // value, that would throw immediately while type system validation\n        // with validateSchema() will produce more actionable results.\n\n\n        const type = getWrappedType(field.type);\n        inputFieldMap[field.name.value] = {\n          type,\n          description: (_field$description2 = field.description) === null || _field$description2 === void 0 ? void 0 : _field$description2.value,\n          defaultValue: valueFromAST(field.defaultValue, type),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field\n        };\n      }\n    }\n\n    return inputFieldMap;\n  }\n\n  function buildEnumValueMap(nodes) {\n    const enumValueMap = Object.create(null);\n\n    for (const node of nodes) {\n      var _node$values; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n\n      const valuesNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];\n\n      for (const value of valuesNodes) {\n        var _value$description;\n\n        enumValueMap[value.name.value] = {\n          description: (_value$description = value.description) === null || _value$description === void 0 ? void 0 : _value$description.value,\n          deprecationReason: getDeprecationReason(value),\n          astNode: value\n        };\n      }\n    }\n\n    return enumValueMap;\n  }\n\n  function buildInterfaces(nodes) {\n    // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    // @ts-expect-error\n    return nodes.flatMap( // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n    node => {\n      var _node$interfaces$map, _node$interfaces;\n\n      return (_node$interfaces$map = (_node$interfaces = node.interfaces) === null || _node$interfaces === void 0 ? void 0 : _node$interfaces.map(getNamedType)) !== null && _node$interfaces$map !== void 0 ? _node$interfaces$map : [];\n    });\n  }\n\n  function buildUnionTypes(nodes) {\n    // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    // @ts-expect-error\n    return nodes.flatMap( // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n    node => {\n      var _node$types$map, _node$types;\n\n      return (_node$types$map = (_node$types = node.types) === null || _node$types === void 0 ? void 0 : _node$types.map(getNamedType)) !== null && _node$types$map !== void 0 ? _node$types$map : [];\n    });\n  }\n\n  function buildType(astNode) {\n    var _typeExtensionsMap$na;\n\n    const name = astNode.name.value;\n    const extensionASTNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];\n\n    switch (astNode.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n        {\n          var _astNode$description;\n\n          const allNodes = [astNode, ...extensionASTNodes];\n          return new GraphQLObjectType({\n            name,\n            description: (_astNode$description = astNode.description) === null || _astNode$description === void 0 ? void 0 : _astNode$description.value,\n            interfaces: () => buildInterfaces(allNodes),\n            fields: () => buildFieldMap(allNodes),\n            astNode,\n            extensionASTNodes\n          });\n        }\n\n      case Kind.INTERFACE_TYPE_DEFINITION:\n        {\n          var _astNode$description2;\n\n          const allNodes = [astNode, ...extensionASTNodes];\n          return new GraphQLInterfaceType({\n            name,\n            description: (_astNode$description2 = astNode.description) === null || _astNode$description2 === void 0 ? void 0 : _astNode$description2.value,\n            interfaces: () => buildInterfaces(allNodes),\n            fields: () => buildFieldMap(allNodes),\n            astNode,\n            extensionASTNodes\n          });\n        }\n\n      case Kind.ENUM_TYPE_DEFINITION:\n        {\n          var _astNode$description3;\n\n          const allNodes = [astNode, ...extensionASTNodes];\n          return new GraphQLEnumType({\n            name,\n            description: (_astNode$description3 = astNode.description) === null || _astNode$description3 === void 0 ? void 0 : _astNode$description3.value,\n            values: buildEnumValueMap(allNodes),\n            astNode,\n            extensionASTNodes\n          });\n        }\n\n      case Kind.UNION_TYPE_DEFINITION:\n        {\n          var _astNode$description4;\n\n          const allNodes = [astNode, ...extensionASTNodes];\n          return new GraphQLUnionType({\n            name,\n            description: (_astNode$description4 = astNode.description) === null || _astNode$description4 === void 0 ? void 0 : _astNode$description4.value,\n            types: () => buildUnionTypes(allNodes),\n            astNode,\n            extensionASTNodes\n          });\n        }\n\n      case Kind.SCALAR_TYPE_DEFINITION:\n        {\n          var _astNode$description5;\n\n          return new GraphQLScalarType({\n            name,\n            description: (_astNode$description5 = astNode.description) === null || _astNode$description5 === void 0 ? void 0 : _astNode$description5.value,\n            specifiedByURL: getSpecifiedByURL(astNode),\n            astNode,\n            extensionASTNodes\n          });\n        }\n\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        {\n          var _astNode$description6;\n\n          const allNodes = [astNode, ...extensionASTNodes];\n          return new GraphQLInputObjectType({\n            name,\n            description: (_astNode$description6 = astNode.description) === null || _astNode$description6 === void 0 ? void 0 : _astNode$description6.value,\n            fields: () => buildInputFieldMap(allNodes),\n            astNode,\n            extensionASTNodes\n          });\n        }\n    } // istanbul ignore next (Not reachable. All possible type definition nodes have been considered)\n\n\n    false || invariant(false, 'Unexpected type definition node: ' + inspect(astNode));\n  }\n}\nconst stdTypeMap = keyMap([...specifiedScalarTypes, ...introspectionTypes], type => type.name);\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\nfunction getDeprecationReason(node) {\n  const deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node); // @ts-expect-error validated by `getDirectiveValues`\n\n  return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;\n}\n/**\n * Given a scalar node, returns the string value for the specifiedByURL.\n */\n\n\nfunction getSpecifiedByURL(node) {\n  const specifiedBy = getDirectiveValues(GraphQLSpecifiedByDirective, node); // @ts-expect-error validated by `getDirectiveValues`\n\n  return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;\n}","map":{"version":3,"sources":["/Users/adammartiska/Projects/eMenu/GUI/eMenu-customer/node_modules/graphql/utilities/extendSchema.mjs"],"names":["keyMap","inspect","mapValue","invariant","devAssert","Kind","isTypeDefinitionNode","isTypeExtensionNode","assertValidSDLExtension","getDirectiveValues","assertSchema","GraphQLSchema","specifiedScalarTypes","isSpecifiedScalarType","introspectionTypes","isIntrospectionType","GraphQLDirective","GraphQLDeprecatedDirective","GraphQLSpecifiedByDirective","isScalarType","isObjectType","isInterfaceType","isUnionType","isListType","isNonNullType","isEnumType","isInputObjectType","GraphQLList","GraphQLNonNull","GraphQLScalarType","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","GraphQLEnumType","GraphQLInputObjectType","valueFromAST","extendSchema","schema","documentAST","options","kind","DOCUMENT","assumeValid","assumeValidSDL","schemaConfig","toConfig","extendedConfig","extendSchemaImpl","_schemaDef","_schemaDef$descriptio","_schemaDef2","_options$assumeValid","typeDefs","typeExtensionsMap","Object","create","directiveDefs","schemaDef","schemaExtensions","def","definitions","SCHEMA_DEFINITION","SCHEMA_EXTENSION","push","extendedTypeName","name","value","existingTypeExtensions","concat","DIRECTIVE_DEFINITION","keys","length","typeMap","existingType","types","extendNamedType","typeNode","_stdTypeMap$name","stdTypeMap","buildType","operationTypes","query","replaceNamedType","mutation","subscription","getOperationTypes","description","values","directives","map","replaceDirective","buildDirective","extensions","astNode","extensionASTNodes","replaceType","type","ofType","directive","config","args","extendArg","extendScalarType","extendObjectType","extendInterfaceType","extendUnionType","extendEnumType","extendInputObjectType","_typeExtensionsMap$co","fields","field","buildInputFieldMap","_typeExtensionsMap$ty","buildEnumValueMap","_typeExtensionsMap$co2","specifiedByURL","extensionNode","_getSpecifiedByURL","getSpecifiedByURL","_typeExtensionsMap$co3","interfaces","getInterfaces","buildInterfaces","extendField","buildFieldMap","_typeExtensionsMap$co4","_typeExtensionsMap$co5","getTypes","buildUnionTypes","arg","nodes","opTypes","node","_node$operationTypes","operationTypesNodes","operationType","operation","getNamedType","_stdTypeMap$name2","undefined","Error","getWrappedType","LIST_TYPE","NON_NULL_TYPE","_node$description","locations","isRepeatable","repeatable","buildArgumentMap","arguments","fieldConfigMap","_node$fields","nodeFields","_field$description","deprecationReason","getDeprecationReason","argsNodes","argConfigMap","_arg$description","defaultValue","inputFieldMap","_node$fields2","fieldsNodes","_field$description2","enumValueMap","_node$values","valuesNodes","_value$description","flatMap","_node$interfaces$map","_node$interfaces","_node$types$map","_node$types","_typeExtensionsMap$na","OBJECT_TYPE_DEFINITION","_astNode$description","allNodes","INTERFACE_TYPE_DEFINITION","_astNode$description2","ENUM_TYPE_DEFINITION","_astNode$description3","UNION_TYPE_DEFINITION","_astNode$description4","SCALAR_TYPE_DEFINITION","_astNode$description5","INPUT_OBJECT_TYPE_DEFINITION","_astNode$description6","deprecated","reason","specifiedBy","url"],"mappings":"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","sourcesContent":["import { keyMap } from '../jsutils/keyMap.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { mapValue } from '../jsutils/mapValue.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { devAssert } from '../jsutils/devAssert.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport {\n  isTypeDefinitionNode,\n  isTypeExtensionNode,\n} from '../language/predicates.mjs';\nimport { assertValidSDLExtension } from '../validation/validate.mjs';\nimport { getDirectiveValues } from '../execution/values.mjs';\nimport { assertSchema, GraphQLSchema } from '../type/schema.mjs';\nimport {\n  specifiedScalarTypes,\n  isSpecifiedScalarType,\n} from '../type/scalars.mjs';\nimport {\n  introspectionTypes,\n  isIntrospectionType,\n} from '../type/introspection.mjs';\nimport {\n  GraphQLDirective,\n  GraphQLDeprecatedDirective,\n  GraphQLSpecifiedByDirective,\n} from '../type/directives.mjs';\nimport {\n  isScalarType,\n  isObjectType,\n  isInterfaceType,\n  isUnionType,\n  isListType,\n  isNonNullType,\n  isEnumType,\n  isInputObjectType,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLScalarType,\n  GraphQLObjectType,\n  GraphQLInterfaceType,\n  GraphQLUnionType,\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n} from '../type/definition.mjs';\nimport { valueFromAST } from './valueFromAST.mjs';\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n */\nexport function extendSchema(schema, documentAST, options) {\n  assertSchema(schema);\n  (documentAST != null && documentAST.kind === Kind.DOCUMENT) ||\n    devAssert(false, 'Must provide valid Document AST.');\n\n  if (\n    (options === null || options === void 0 ? void 0 : options.assumeValid) !==\n      true &&\n    (options === null || options === void 0\n      ? void 0\n      : options.assumeValidSDL) !== true\n  ) {\n    assertValidSDLExtension(documentAST, schema);\n  }\n\n  const schemaConfig = schema.toConfig();\n  const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);\n  return schemaConfig === extendedConfig\n    ? schema\n    : new GraphQLSchema(extendedConfig);\n}\n/**\n * @internal\n */\n\nexport function extendSchemaImpl(schemaConfig, documentAST, options) {\n  var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;\n\n  // Collect the type definitions and extensions found in the document.\n  const typeDefs = [];\n  const typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  const directiveDefs = [];\n  let schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  const schemaExtensions = [];\n\n  for (const def of documentAST.definitions) {\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (def.kind === Kind.SCHEMA_EXTENSION) {\n      schemaExtensions.push(def);\n    } else if (isTypeDefinitionNode(def)) {\n      typeDefs.push(def);\n    } else if (isTypeExtensionNode(def)) {\n      const extendedTypeName = def.name.value;\n      const existingTypeExtensions = typeExtensionsMap[extendedTypeName];\n      typeExtensionsMap[extendedTypeName] = existingTypeExtensions\n        ? existingTypeExtensions.concat([def])\n        : [def];\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n  if (\n    Object.keys(typeExtensionsMap).length === 0 &&\n    typeDefs.length === 0 &&\n    directiveDefs.length === 0 &&\n    schemaExtensions.length === 0 &&\n    schemaDef == null\n  ) {\n    return schemaConfig;\n  }\n\n  const typeMap = Object.create(null);\n\n  for (const existingType of schemaConfig.types) {\n    typeMap[existingType.name] = extendNamedType(existingType);\n  }\n\n  for (const typeNode of typeDefs) {\n    var _stdTypeMap$name;\n\n    const name = typeNode.name.value;\n    typeMap[name] =\n      (_stdTypeMap$name = stdTypeMap[name]) !== null &&\n      _stdTypeMap$name !== void 0\n        ? _stdTypeMap$name\n        : buildType(typeNode);\n  }\n\n  const operationTypes = {\n    // Get the extended root operation types.\n    query: schemaConfig.query && replaceNamedType(schemaConfig.query),\n    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),\n    subscription:\n      schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),\n    // Then, incorporate schema definition and all schema extensions.\n    ...(schemaDef && getOperationTypes([schemaDef])),\n    ...getOperationTypes(schemaExtensions),\n  }; // Then produce and return a Schema config with these types.\n\n  return {\n    description:\n      (_schemaDef = schemaDef) === null || _schemaDef === void 0\n        ? void 0\n        : (_schemaDef$descriptio = _schemaDef.description) === null ||\n          _schemaDef$descriptio === void 0\n        ? void 0\n        : _schemaDef$descriptio.value,\n    ...operationTypes,\n    types: Object.values(typeMap),\n    directives: [\n      ...schemaConfig.directives.map(replaceDirective),\n      ...directiveDefs.map(buildDirective),\n    ],\n    extensions: Object.create(null),\n    astNode:\n      (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0\n        ? _schemaDef2\n        : schemaConfig.astNode,\n    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),\n    assumeValid:\n      (_options$assumeValid =\n        options === null || options === void 0\n          ? void 0\n          : options.assumeValid) !== null && _options$assumeValid !== void 0\n        ? _options$assumeValid\n        : false,\n  }; // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function replaceType(type) {\n    if (isListType(type)) {\n      // @ts-expect-error\n      return new GraphQLList(replaceType(type.ofType));\n    }\n\n    if (isNonNullType(type)) {\n      // @ts-expect-error\n      return new GraphQLNonNull(replaceType(type.ofType));\n    } // @ts-expect-error FIXME\n\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType(type) {\n    // Note: While this could make early assertions to get the correctly\n    // typed values, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    return typeMap[type.name];\n  }\n\n  function replaceDirective(directive) {\n    const config = directive.toConfig();\n    return new GraphQLDirective({\n      ...config,\n      args: mapValue(config.args, extendArg),\n    });\n  }\n\n  function extendNamedType(type) {\n    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {\n      // Builtin types are not extended.\n      return type;\n    }\n\n    if (isScalarType(type)) {\n      return extendScalarType(type);\n    }\n\n    if (isObjectType(type)) {\n      return extendObjectType(type);\n    }\n\n    if (isInterfaceType(type)) {\n      return extendInterfaceType(type);\n    }\n\n    if (isUnionType(type)) {\n      return extendUnionType(type);\n    }\n\n    if (isEnumType(type)) {\n      return extendEnumType(type);\n    } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n    if (isInputObjectType(type)) {\n      return extendInputObjectType(type);\n    } // istanbul ignore next (Not reachable. All possible types have been considered)\n\n    false || invariant(false, 'Unexpected type: ' + inspect(type));\n  }\n\n  function extendInputObjectType(type) {\n    var _typeExtensionsMap$co;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co !== void 0\n        ? _typeExtensionsMap$co\n        : [];\n    return new GraphQLInputObjectType({\n      ...config,\n      fields: () => ({\n        ...mapValue(config.fields, (field) => ({\n          ...field,\n          type: replaceType(field.type),\n        })),\n        ...buildInputFieldMap(extensions),\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendEnumType(type) {\n    var _typeExtensionsMap$ty;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null &&\n      _typeExtensionsMap$ty !== void 0\n        ? _typeExtensionsMap$ty\n        : [];\n    return new GraphQLEnumType({\n      ...config,\n      values: { ...config.values, ...buildEnumValueMap(extensions) },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendScalarType(type) {\n    var _typeExtensionsMap$co2;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co2 !== void 0\n        ? _typeExtensionsMap$co2\n        : [];\n    let specifiedByURL = config.specifiedByURL;\n\n    for (const extensionNode of extensions) {\n      var _getSpecifiedByURL;\n\n      specifiedByURL =\n        (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null &&\n        _getSpecifiedByURL !== void 0\n          ? _getSpecifiedByURL\n          : specifiedByURL;\n    }\n\n    return new GraphQLScalarType({\n      ...config,\n      specifiedByURL,\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendObjectType(type) {\n    var _typeExtensionsMap$co3;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co3 !== void 0\n        ? _typeExtensionsMap$co3\n        : [];\n    return new GraphQLObjectType({\n      ...config,\n      interfaces: () => [\n        ...type.getInterfaces().map(replaceNamedType),\n        ...buildInterfaces(extensions),\n      ],\n      fields: () => ({\n        ...mapValue(config.fields, extendField),\n        ...buildFieldMap(extensions),\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendInterfaceType(type) {\n    var _typeExtensionsMap$co4;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co4 !== void 0\n        ? _typeExtensionsMap$co4\n        : [];\n    return new GraphQLInterfaceType({\n      ...config,\n      interfaces: () => [\n        ...type.getInterfaces().map(replaceNamedType),\n        ...buildInterfaces(extensions),\n      ],\n      fields: () => ({\n        ...mapValue(config.fields, extendField),\n        ...buildFieldMap(extensions),\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendUnionType(type) {\n    var _typeExtensionsMap$co5;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co5 !== void 0\n        ? _typeExtensionsMap$co5\n        : [];\n    return new GraphQLUnionType({\n      ...config,\n      types: () => [\n        ...type.getTypes().map(replaceNamedType),\n        ...buildUnionTypes(extensions),\n      ],\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendField(field) {\n    return {\n      ...field,\n      type: replaceType(field.type),\n      args: field.args && mapValue(field.args, extendArg),\n    };\n  }\n\n  function extendArg(arg) {\n    return { ...arg, type: replaceType(arg.type) };\n  }\n\n  function getOperationTypes(nodes) {\n    const opTypes = {};\n\n    for (const node of nodes) {\n      var _node$operationTypes;\n\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      const operationTypesNodes =\n        (_node$operationTypes = node.operationTypes) !== null &&\n        _node$operationTypes !== void 0\n          ? _node$operationTypes\n          : [];\n\n      for (const operationType of operationTypesNodes) {\n        // Note: While this could make early assertions to get the correctly\n        // typed values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n        // @ts-expect-error\n        opTypes[operationType.operation] = getNamedType(operationType.type);\n      }\n    }\n\n    return opTypes;\n  }\n\n  function getNamedType(node) {\n    var _stdTypeMap$name2;\n\n    const name = node.name.value;\n    const type =\n      (_stdTypeMap$name2 = stdTypeMap[name]) !== null &&\n      _stdTypeMap$name2 !== void 0\n        ? _stdTypeMap$name2\n        : typeMap[name];\n\n    if (type === undefined) {\n      throw new Error(`Unknown type: \"${name}\".`);\n    }\n\n    return type;\n  }\n\n  function getWrappedType(node) {\n    if (node.kind === Kind.LIST_TYPE) {\n      return new GraphQLList(getWrappedType(node.type));\n    }\n\n    if (node.kind === Kind.NON_NULL_TYPE) {\n      return new GraphQLNonNull(getWrappedType(node.type));\n    }\n\n    return getNamedType(node);\n  }\n\n  function buildDirective(node) {\n    var _node$description;\n\n    return new GraphQLDirective({\n      name: node.name.value,\n      description:\n        (_node$description = node.description) === null ||\n        _node$description === void 0\n          ? void 0\n          : _node$description.value,\n      // @ts-expect-error\n      locations: node.locations.map(({ value }) => value),\n      isRepeatable: node.repeatable,\n      args: buildArgumentMap(node.arguments),\n      astNode: node,\n    });\n  }\n\n  function buildFieldMap(nodes) {\n    const fieldConfigMap = Object.create(null);\n\n    for (const node of nodes) {\n      var _node$fields;\n\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      const nodeFields =\n        (_node$fields = node.fields) !== null && _node$fields !== void 0\n          ? _node$fields\n          : [];\n\n      for (const field of nodeFields) {\n        var _field$description;\n\n        fieldConfigMap[field.name.value] = {\n          // Note: While this could make assertions to get the correctly typed\n          // value, that would throw immediately while type system validation\n          // with validateSchema() will produce more actionable results.\n          type: getWrappedType(field.type),\n          description:\n            (_field$description = field.description) === null ||\n            _field$description === void 0\n              ? void 0\n              : _field$description.value,\n          args: buildArgumentMap(field.arguments),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field,\n        };\n      }\n    }\n\n    return fieldConfigMap;\n  }\n\n  function buildArgumentMap(args) {\n    // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n    const argsNodes = args !== null && args !== void 0 ? args : [];\n    const argConfigMap = Object.create(null);\n\n    for (const arg of argsNodes) {\n      var _arg$description;\n\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n      const type = getWrappedType(arg.type);\n      argConfigMap[arg.name.value] = {\n        type,\n        description:\n          (_arg$description = arg.description) === null ||\n          _arg$description === void 0\n            ? void 0\n            : _arg$description.value,\n        defaultValue: valueFromAST(arg.defaultValue, type),\n        deprecationReason: getDeprecationReason(arg),\n        astNode: arg,\n      };\n    }\n\n    return argConfigMap;\n  }\n\n  function buildInputFieldMap(nodes) {\n    const inputFieldMap = Object.create(null);\n\n    for (const node of nodes) {\n      var _node$fields2;\n\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      const fieldsNodes =\n        (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0\n          ? _node$fields2\n          : [];\n\n      for (const field of fieldsNodes) {\n        var _field$description2;\n\n        // Note: While this could make assertions to get the correctly typed\n        // value, that would throw immediately while type system validation\n        // with validateSchema() will produce more actionable results.\n        const type = getWrappedType(field.type);\n        inputFieldMap[field.name.value] = {\n          type,\n          description:\n            (_field$description2 = field.description) === null ||\n            _field$description2 === void 0\n              ? void 0\n              : _field$description2.value,\n          defaultValue: valueFromAST(field.defaultValue, type),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field,\n        };\n      }\n    }\n\n    return inputFieldMap;\n  }\n\n  function buildEnumValueMap(nodes) {\n    const enumValueMap = Object.create(null);\n\n    for (const node of nodes) {\n      var _node$values;\n\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      const valuesNodes =\n        (_node$values = node.values) !== null && _node$values !== void 0\n          ? _node$values\n          : [];\n\n      for (const value of valuesNodes) {\n        var _value$description;\n\n        enumValueMap[value.name.value] = {\n          description:\n            (_value$description = value.description) === null ||\n            _value$description === void 0\n              ? void 0\n              : _value$description.value,\n          deprecationReason: getDeprecationReason(value),\n          astNode: value,\n        };\n      }\n    }\n\n    return enumValueMap;\n  }\n\n  function buildInterfaces(nodes) {\n    // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    // @ts-expect-error\n    return nodes.flatMap(\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      (node) => {\n        var _node$interfaces$map, _node$interfaces;\n\n        return (_node$interfaces$map =\n          (_node$interfaces = node.interfaces) === null ||\n          _node$interfaces === void 0\n            ? void 0\n            : _node$interfaces.map(getNamedType)) !== null &&\n          _node$interfaces$map !== void 0\n          ? _node$interfaces$map\n          : [];\n      },\n    );\n  }\n\n  function buildUnionTypes(nodes) {\n    // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    // @ts-expect-error\n    return nodes.flatMap(\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      (node) => {\n        var _node$types$map, _node$types;\n\n        return (_node$types$map =\n          (_node$types = node.types) === null || _node$types === void 0\n            ? void 0\n            : _node$types.map(getNamedType)) !== null &&\n          _node$types$map !== void 0\n          ? _node$types$map\n          : [];\n      },\n    );\n  }\n\n  function buildType(astNode) {\n    var _typeExtensionsMap$na;\n\n    const name = astNode.name.value;\n    const extensionASTNodes =\n      (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null &&\n      _typeExtensionsMap$na !== void 0\n        ? _typeExtensionsMap$na\n        : [];\n\n    switch (astNode.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION: {\n        var _astNode$description;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new GraphQLObjectType({\n          name,\n          description:\n            (_astNode$description = astNode.description) === null ||\n            _astNode$description === void 0\n              ? void 0\n              : _astNode$description.value,\n          interfaces: () => buildInterfaces(allNodes),\n          fields: () => buildFieldMap(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case Kind.INTERFACE_TYPE_DEFINITION: {\n        var _astNode$description2;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new GraphQLInterfaceType({\n          name,\n          description:\n            (_astNode$description2 = astNode.description) === null ||\n            _astNode$description2 === void 0\n              ? void 0\n              : _astNode$description2.value,\n          interfaces: () => buildInterfaces(allNodes),\n          fields: () => buildFieldMap(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case Kind.ENUM_TYPE_DEFINITION: {\n        var _astNode$description3;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new GraphQLEnumType({\n          name,\n          description:\n            (_astNode$description3 = astNode.description) === null ||\n            _astNode$description3 === void 0\n              ? void 0\n              : _astNode$description3.value,\n          values: buildEnumValueMap(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case Kind.UNION_TYPE_DEFINITION: {\n        var _astNode$description4;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new GraphQLUnionType({\n          name,\n          description:\n            (_astNode$description4 = astNode.description) === null ||\n            _astNode$description4 === void 0\n              ? void 0\n              : _astNode$description4.value,\n          types: () => buildUnionTypes(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case Kind.SCALAR_TYPE_DEFINITION: {\n        var _astNode$description5;\n\n        return new GraphQLScalarType({\n          name,\n          description:\n            (_astNode$description5 = astNode.description) === null ||\n            _astNode$description5 === void 0\n              ? void 0\n              : _astNode$description5.value,\n          specifiedByURL: getSpecifiedByURL(astNode),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION: {\n        var _astNode$description6;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new GraphQLInputObjectType({\n          name,\n          description:\n            (_astNode$description6 = astNode.description) === null ||\n            _astNode$description6 === void 0\n              ? void 0\n              : _astNode$description6.value,\n          fields: () => buildInputFieldMap(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n    } // istanbul ignore next (Not reachable. All possible type definition nodes have been considered)\n\n    false ||\n      invariant(false, 'Unexpected type definition node: ' + inspect(astNode));\n  }\n}\nconst stdTypeMap = keyMap(\n  [...specifiedScalarTypes, ...introspectionTypes],\n  (type) => type.name,\n);\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\nfunction getDeprecationReason(node) {\n  const deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node); // @ts-expect-error validated by `getDirectiveValues`\n\n  return deprecated === null || deprecated === void 0\n    ? void 0\n    : deprecated.reason;\n}\n/**\n * Given a scalar node, returns the string value for the specifiedByURL.\n */\n\nfunction getSpecifiedByURL(node) {\n  const specifiedBy = getDirectiveValues(GraphQLSpecifiedByDirective, node); // @ts-expect-error validated by `getDirectiveValues`\n\n  return specifiedBy === null || specifiedBy === void 0\n    ? void 0\n    : specifiedBy.url;\n}\n"]},"metadata":{},"sourceType":"module"}