{"ast":null,"code":"import { inspect } from '../jsutils/inspect.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { OperationTypeNode } from '../language/ast.mjs';\nimport { isEqualType, isTypeSubTypeOf } from '../utilities/typeComparators.mjs';\nimport { assertSchema } from './schema.mjs';\nimport { isIntrospectionType } from './introspection.mjs';\nimport { isDirective, GraphQLDeprecatedDirective } from './directives.mjs';\nimport { isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNamedType, isNonNullType, isInputType, isOutputType, isRequiredArgument, isRequiredInputField } from './definition.mjs';\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\n\nexport function validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  assertSchema(schema); // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n\n  const context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  const errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\nexport function assertValidSchema(schema) {\n  const errors = validateSchema(schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(error => error.message).join('\\n\\n'));\n  }\n}\n\nclass SchemaValidationContext {\n  constructor(schema) {\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  reportError(message, nodes) {\n    const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;\n\n    this._errors.push(new GraphQLError(message, _nodes));\n  }\n\n  getErrors() {\n    return this._errors;\n  }\n\n}\n\nfunction validateRootTypes(context) {\n  const schema = context.schema;\n  const queryType = schema.getQueryType();\n\n  if (!queryType) {\n    context.reportError('Query root type must be provided.', schema.astNode);\n  } else if (!isObjectType(queryType)) {\n    var _getOperationTypeNode;\n\n    context.reportError(`Query root type must be Object type, it cannot be ${inspect(queryType)}.`, (_getOperationTypeNode = getOperationTypeNode(schema, OperationTypeNode.QUERY)) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode);\n  }\n\n  const mutationType = schema.getMutationType();\n\n  if (mutationType && !isObjectType(mutationType)) {\n    var _getOperationTypeNode2;\n\n    context.reportError('Mutation root type must be Object type if provided, it cannot be ' + `${inspect(mutationType)}.`, (_getOperationTypeNode2 = getOperationTypeNode(schema, OperationTypeNode.MUTATION)) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode);\n  }\n\n  const subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && !isObjectType(subscriptionType)) {\n    var _getOperationTypeNode3;\n\n    context.reportError('Subscription root type must be Object type if provided, it cannot be ' + `${inspect(subscriptionType)}.`, (_getOperationTypeNode3 = getOperationTypeNode(schema, OperationTypeNode.SUBSCRIPTION)) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode);\n  }\n}\n\nfunction getOperationTypeNode(schema, operation) {\n  var _flatMap$find; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n\n  return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes].flatMap(schemaNode => {\n    var _schemaNode$operation;\n\n    return (_schemaNode$operation = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.operationTypes) !== null && _schemaNode$operation !== void 0 ? _schemaNode$operation : [];\n  }).find(operationNode => operationNode.operation === operation)) === null || _flatMap$find === void 0 ? void 0 : _flatMap$find.type;\n}\n\nfunction validateDirectives(context) {\n  for (const directive of context.schema.getDirectives()) {\n    // Ensure all directives are in fact GraphQL directives.\n    if (!isDirective(directive)) {\n      context.reportError(`Expected directive but got: ${inspect(directive)}.`, directive === null || directive === void 0 ? void 0 : directive.astNode);\n      continue;\n    } // Ensure they are named correctly.\n\n\n    validateName(context, directive); // TODO: Ensure proper locations.\n    // Ensure the arguments are valid.\n\n    for (const arg of directive.args) {\n      // Ensure they are named correctly.\n      validateName(context, arg); // Ensure the type is an input type.\n\n      if (!isInputType(arg.type)) {\n        context.reportError(`The type of @${directive.name}(${arg.name}:) must be Input Type ` + `but got: ${inspect(arg.type)}.`, arg.astNode);\n      }\n\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        var _arg$astNode;\n\n        context.reportError(`Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`, [getDeprecatedDirectiveNode(arg.astNode), (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type]);\n      }\n    }\n  }\n}\n\nfunction validateName(context, node) {\n  // Ensure names are valid, however introspection types opt out.\n  if (node.name.startsWith('__')) {\n    context.reportError(`Name \"${node.name}\" must not begin with \"__\", which is reserved by GraphQL introspection.`, node.astNode);\n  }\n}\n\nfunction validateTypes(context) {\n  const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);\n  const typeMap = context.schema.getTypeMap();\n\n  for (const type of Object.values(typeMap)) {\n    // Ensure all provided types are in fact GraphQL type.\n    if (!isNamedType(type)) {\n      context.reportError(`Expected GraphQL named type but got: ${inspect(type)}.`, type.astNode);\n      continue;\n    } // Ensure it is named correctly (excluding introspection types).\n\n\n    if (!isIntrospectionType(type)) {\n      validateName(context, type);\n    }\n\n    if (isObjectType(type)) {\n      // Ensure fields are valid\n      validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isInterfaceType(type)) {\n      // Ensure fields are valid.\n      validateFields(context, type); // Ensure interfaces implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isUnionType(type)) {\n      // Ensure Unions include valid member types.\n      validateUnionMembers(context, type);\n    } else if (isEnumType(type)) {\n      // Ensure Enums have valid values.\n      validateEnumValues(context, type);\n    } else if (isInputObjectType(type)) {\n      // Ensure Input Object fields are valid.\n      validateInputFields(context, type); // Ensure Input Objects do not contain non-nullable circular references\n\n      validateInputObjectCircularRefs(type);\n    }\n  }\n}\n\nfunction validateFields(context, type) {\n  const fields = Object.values(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(`Type ${type.name} must define one or more fields.`, [type.astNode, ...type.extensionASTNodes]);\n  }\n\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an output type\n\n    if (!isOutputType(field.type)) {\n      var _field$astNode;\n\n      context.reportError(`The type of ${type.name}.${field.name} must be Output Type ` + `but got: ${inspect(field.type)}.`, (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type);\n    } // Ensure the arguments are valid\n\n\n    for (const arg of field.args) {\n      const argName = arg.name; // Ensure they are named correctly.\n\n      validateName(context, arg); // Ensure the type is an input type\n\n      if (!isInputType(arg.type)) {\n        var _arg$astNode2;\n\n        context.reportError(`The type of ${type.name}.${field.name}(${argName}:) must be Input ` + `Type but got: ${inspect(arg.type)}.`, (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type);\n      }\n\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        var _arg$astNode3;\n\n        context.reportError(`Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`, [getDeprecatedDirectiveNode(arg.astNode), (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type]);\n      }\n    }\n  }\n}\n\nfunction validateInterfaces(context, type) {\n  const ifaceTypeNames = Object.create(null);\n\n  for (const iface of type.getInterfaces()) {\n    if (!isInterfaceType(iface)) {\n      context.reportError(`Type ${inspect(type)} must only implement Interface types, ` + `it cannot implement ${inspect(iface)}.`, getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n\n    if (type === iface) {\n      context.reportError(`Type ${type.name} cannot implement itself because it would create a circular reference.`, getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n\n    if (ifaceTypeNames[iface.name]) {\n      context.reportError(`Type ${type.name} can only implement ${iface.name} once.`, getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n\n    ifaceTypeNames[iface.name] = true;\n    validateTypeImplementsAncestors(context, type, iface);\n    validateTypeImplementsInterface(context, type, iface);\n  }\n}\n\nfunction validateTypeImplementsInterface(context, type, iface) {\n  const typeFieldMap = type.getFields(); // Assert each interface field is implemented.\n\n  for (const ifaceField of Object.values(iface.getFields())) {\n    const fieldName = ifaceField.name;\n    const typeField = typeFieldMap[fieldName]; // Assert interface field exists on type.\n\n    if (!typeField) {\n      context.reportError(`Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`, [ifaceField.astNode, type.astNode, ...type.extensionASTNodes]);\n      continue;\n    } // Assert interface field type is satisfied by type field type, by being\n    // a valid subtype. (covariant)\n\n\n    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {\n      var _ifaceField$astNode, _typeField$astNode;\n\n      context.reportError(`Interface field ${iface.name}.${fieldName} expects type ` + `${inspect(ifaceField.type)} but ${type.name}.${fieldName} ` + `is type ${inspect(typeField.type)}.`, [(_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type, (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type]);\n    } // Assert each interface field arg is implemented.\n\n\n    for (const ifaceArg of ifaceField.args) {\n      const argName = ifaceArg.name;\n      const typeArg = typeField.args.find(arg => arg.name === argName); // Assert interface field arg exists on object field.\n\n      if (!typeArg) {\n        context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`, [ifaceArg.astNode, typeField.astNode]);\n        continue;\n      } // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      // TODO: change to contravariant?\n\n\n      if (!isEqualType(ifaceArg.type, typeArg.type)) {\n        var _ifaceArg$astNode, _typeArg$astNode;\n\n        context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) ` + `expects type ${inspect(ifaceArg.type)} but ` + `${type.name}.${fieldName}(${argName}:) is type ` + `${inspect(typeArg.type)}.`, [// istanbul ignore next (TODO need to write coverage tests)\n        (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type, // istanbul ignore next (TODO need to write coverage tests)\n        (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type]);\n      } // TODO: validate default values?\n\n    } // Assert additional arguments must not be required.\n\n\n    for (const typeArg of typeField.args) {\n      const argName = typeArg.name;\n      const ifaceArg = ifaceField.args.find(arg => arg.name === argName);\n\n      if (!ifaceArg && isRequiredArgument(typeArg)) {\n        context.reportError(`Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`, [typeArg.astNode, ifaceField.astNode]);\n      }\n    }\n  }\n}\n\nfunction validateTypeImplementsAncestors(context, type, iface) {\n  const ifaceInterfaces = type.getInterfaces();\n\n  for (const transitive of iface.getInterfaces()) {\n    if (!ifaceInterfaces.includes(transitive)) {\n      context.reportError(transitive === type ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`, [...getAllImplementsInterfaceNodes(iface, transitive), ...getAllImplementsInterfaceNodes(type, iface)]);\n    }\n  }\n}\n\nfunction validateUnionMembers(context, union) {\n  const memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError(`Union type ${union.name} must define one or more member types.`, [union.astNode, ...union.extensionASTNodes]);\n  }\n\n  const includedTypeNames = Object.create(null);\n\n  for (const memberType of memberTypes) {\n    if (includedTypeNames[memberType.name]) {\n      context.reportError(`Union type ${union.name} can only include type ${memberType.name} once.`, getUnionMemberTypeNodes(union, memberType.name));\n      continue;\n    }\n\n    includedTypeNames[memberType.name] = true;\n\n    if (!isObjectType(memberType)) {\n      context.reportError(`Union type ${union.name} can only include Object types, ` + `it cannot include ${inspect(memberType)}.`, getUnionMemberTypeNodes(union, String(memberType)));\n    }\n  }\n}\n\nfunction validateEnumValues(context, enumType) {\n  const enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError(`Enum type ${enumType.name} must define one or more values.`, [enumType.astNode, ...enumType.extensionASTNodes]);\n  }\n\n  for (const enumValue of enumValues) {\n    // Ensure valid name.\n    validateName(context, enumValue);\n  }\n}\n\nfunction validateInputFields(context, inputObj) {\n  const fields = Object.values(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError(`Input Object type ${inputObj.name} must define one or more fields.`, [inputObj.astNode, ...inputObj.extensionASTNodes]);\n  } // Ensure the arguments are valid\n\n\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an input type\n\n    if (!isInputType(field.type)) {\n      var _field$astNode2;\n\n      context.reportError(`The type of ${inputObj.name}.${field.name} must be Input Type ` + `but got: ${inspect(field.type)}.`, (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type);\n    }\n\n    if (isRequiredInputField(field) && field.deprecationReason != null) {\n      var _field$astNode3;\n\n      context.reportError(`Required input field ${inputObj.name}.${field.name} cannot be deprecated.`, [getDeprecatedDirectiveNode(field.astNode), // istanbul ignore next (TODO need to write coverage tests)\n      (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type]);\n    }\n  }\n}\n\nfunction createInputObjectCircularRefsValidator(context) {\n  // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.\n  // Tracks already visited types to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  const visitedTypes = Object.create(null); // Array of types nodes used to produce meaningful errors\n\n  const fieldPath = []; // Position in the type path\n\n  const fieldPathIndexByTypeName = Object.create(null);\n  return detectCycleRecursive; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(inputObj) {\n    if (visitedTypes[inputObj.name]) {\n      return;\n    }\n\n    visitedTypes[inputObj.name] = true;\n    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;\n    const fields = Object.values(inputObj.getFields());\n\n    for (const field of fields) {\n      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {\n        const fieldType = field.type.ofType;\n        const cycleIndex = fieldPathIndexByTypeName[fieldType.name];\n        fieldPath.push(field);\n\n        if (cycleIndex === undefined) {\n          detectCycleRecursive(fieldType);\n        } else {\n          const cyclePath = fieldPath.slice(cycleIndex);\n          const pathStr = cyclePath.map(fieldObj => fieldObj.name).join('.');\n          context.reportError(`Cannot reference Input Object \"${fieldType.name}\" within itself through a series of non-null fields: \"${pathStr}\".`, cyclePath.map(fieldObj => fieldObj.astNode));\n        }\n\n        fieldPath.pop();\n      }\n    }\n\n    fieldPathIndexByTypeName[inputObj.name] = undefined;\n  }\n}\n\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  const {\n    astNode,\n    extensionASTNodes\n  } = type;\n  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n  return nodes.flatMap(typeNode => {\n    var _typeNode$interfaces;\n\n    return (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== void 0 ? _typeNode$interfaces : [];\n  }).filter(ifaceNode => ifaceNode.name.value === iface.name);\n}\n\nfunction getUnionMemberTypeNodes(union, typeName) {\n  const {\n    astNode,\n    extensionASTNodes\n  } = union;\n  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n  return nodes.flatMap(unionNode => {\n    var _unionNode$types;\n\n    return (_unionNode$types = unionNode.types) !== null && _unionNode$types !== void 0 ? _unionNode$types : [];\n  }).filter(typeNode => typeNode.name.value === typeName);\n}\n\nfunction getDeprecatedDirectiveNode(definitionNode) {\n  var _definitionNode$direc; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n\n  return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(node => node.name.value === GraphQLDeprecatedDirective.name);\n}","map":{"version":3,"sources":["/Users/adammartiska/Projects/eMenu/GUI/eMenu-customer/node_modules/graphql/type/validate.mjs"],"names":["inspect","GraphQLError","OperationTypeNode","isEqualType","isTypeSubTypeOf","assertSchema","isIntrospectionType","isDirective","GraphQLDeprecatedDirective","isObjectType","isInterfaceType","isUnionType","isEnumType","isInputObjectType","isNamedType","isNonNullType","isInputType","isOutputType","isRequiredArgument","isRequiredInputField","validateSchema","schema","__validationErrors","context","SchemaValidationContext","validateRootTypes","validateDirectives","validateTypes","errors","getErrors","assertValidSchema","length","Error","map","error","message","join","constructor","_errors","reportError","nodes","_nodes","Array","isArray","filter","Boolean","push","queryType","getQueryType","astNode","_getOperationTypeNode","getOperationTypeNode","QUERY","mutationType","getMutationType","_getOperationTypeNode2","MUTATION","subscriptionType","getSubscriptionType","_getOperationTypeNode3","SUBSCRIPTION","operation","_flatMap$find","extensionASTNodes","flatMap","schemaNode","_schemaNode$operation","operationTypes","find","operationNode","type","directive","getDirectives","validateName","arg","args","name","deprecationReason","_arg$astNode","getDeprecatedDirectiveNode","node","startsWith","validateInputObjectCircularRefs","createInputObjectCircularRefsValidator","typeMap","getTypeMap","Object","values","validateFields","validateInterfaces","validateUnionMembers","validateEnumValues","validateInputFields","fields","getFields","field","_field$astNode","argName","_arg$astNode2","_arg$astNode3","ifaceTypeNames","create","iface","getInterfaces","getAllImplementsInterfaceNodes","validateTypeImplementsAncestors","validateTypeImplementsInterface","typeFieldMap","ifaceField","fieldName","typeField","_ifaceField$astNode","_typeField$astNode","ifaceArg","typeArg","_ifaceArg$astNode","_typeArg$astNode","ifaceInterfaces","transitive","includes","union","memberTypes","getTypes","includedTypeNames","memberType","getUnionMemberTypeNodes","String","enumType","enumValues","getValues","enumValue","inputObj","_field$astNode2","_field$astNode3","visitedTypes","fieldPath","fieldPathIndexByTypeName","detectCycleRecursive","ofType","fieldType","cycleIndex","undefined","cyclePath","slice","pathStr","fieldObj","pop","typeNode","_typeNode$interfaces","interfaces","ifaceNode","value","typeName","unionNode","_unionNode$types","types","definitionNode","_definitionNode$direc","directives"],"mappings":"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","sourcesContent":["import { inspect } from '../jsutils/inspect.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { OperationTypeNode } from '../language/ast.mjs';\nimport { isEqualType, isTypeSubTypeOf } from '../utilities/typeComparators.mjs';\nimport { assertSchema } from './schema.mjs';\nimport { isIntrospectionType } from './introspection.mjs';\nimport { isDirective, GraphQLDeprecatedDirective } from './directives.mjs';\nimport {\n  isObjectType,\n  isInterfaceType,\n  isUnionType,\n  isEnumType,\n  isInputObjectType,\n  isNamedType,\n  isNonNullType,\n  isInputType,\n  isOutputType,\n  isRequiredArgument,\n  isRequiredInputField,\n} from './definition.mjs';\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\n\nexport function validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  assertSchema(schema); // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n  const context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  const errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\nexport function assertValidSchema(schema) {\n  const errors = validateSchema(schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map((error) => error.message).join('\\n\\n'));\n  }\n}\n\nclass SchemaValidationContext {\n  constructor(schema) {\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  reportError(message, nodes) {\n    const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;\n\n    this._errors.push(new GraphQLError(message, _nodes));\n  }\n\n  getErrors() {\n    return this._errors;\n  }\n}\n\nfunction validateRootTypes(context) {\n  const schema = context.schema;\n  const queryType = schema.getQueryType();\n\n  if (!queryType) {\n    context.reportError('Query root type must be provided.', schema.astNode);\n  } else if (!isObjectType(queryType)) {\n    var _getOperationTypeNode;\n\n    context.reportError(\n      `Query root type must be Object type, it cannot be ${inspect(\n        queryType,\n      )}.`,\n      (_getOperationTypeNode = getOperationTypeNode(\n        schema,\n        OperationTypeNode.QUERY,\n      )) !== null && _getOperationTypeNode !== void 0\n        ? _getOperationTypeNode\n        : queryType.astNode,\n    );\n  }\n\n  const mutationType = schema.getMutationType();\n\n  if (mutationType && !isObjectType(mutationType)) {\n    var _getOperationTypeNode2;\n\n    context.reportError(\n      'Mutation root type must be Object type if provided, it cannot be ' +\n        `${inspect(mutationType)}.`,\n      (_getOperationTypeNode2 = getOperationTypeNode(\n        schema,\n        OperationTypeNode.MUTATION,\n      )) !== null && _getOperationTypeNode2 !== void 0\n        ? _getOperationTypeNode2\n        : mutationType.astNode,\n    );\n  }\n\n  const subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && !isObjectType(subscriptionType)) {\n    var _getOperationTypeNode3;\n\n    context.reportError(\n      'Subscription root type must be Object type if provided, it cannot be ' +\n        `${inspect(subscriptionType)}.`,\n      (_getOperationTypeNode3 = getOperationTypeNode(\n        schema,\n        OperationTypeNode.SUBSCRIPTION,\n      )) !== null && _getOperationTypeNode3 !== void 0\n        ? _getOperationTypeNode3\n        : subscriptionType.astNode,\n    );\n  }\n}\n\nfunction getOperationTypeNode(schema, operation) {\n  var _flatMap$find;\n\n  // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n  return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes]\n    .flatMap((schemaNode) => {\n      var _schemaNode$operation;\n\n      return (_schemaNode$operation =\n        schemaNode === null || schemaNode === void 0\n          ? void 0\n          : schemaNode.operationTypes) !== null &&\n        _schemaNode$operation !== void 0\n        ? _schemaNode$operation\n        : [];\n    })\n    .find((operationNode) => operationNode.operation === operation)) === null ||\n    _flatMap$find === void 0\n    ? void 0\n    : _flatMap$find.type;\n}\n\nfunction validateDirectives(context) {\n  for (const directive of context.schema.getDirectives()) {\n    // Ensure all directives are in fact GraphQL directives.\n    if (!isDirective(directive)) {\n      context.reportError(\n        `Expected directive but got: ${inspect(directive)}.`,\n        directive === null || directive === void 0 ? void 0 : directive.astNode,\n      );\n      continue;\n    } // Ensure they are named correctly.\n\n    validateName(context, directive); // TODO: Ensure proper locations.\n    // Ensure the arguments are valid.\n\n    for (const arg of directive.args) {\n      // Ensure they are named correctly.\n      validateName(context, arg); // Ensure the type is an input type.\n\n      if (!isInputType(arg.type)) {\n        context.reportError(\n          `The type of @${directive.name}(${arg.name}:) must be Input Type ` +\n            `but got: ${inspect(arg.type)}.`,\n          arg.astNode,\n        );\n      }\n\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        var _arg$astNode;\n\n        context.reportError(\n          `Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`,\n          [\n            getDeprecatedDirectiveNode(arg.astNode),\n            (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0\n              ? void 0\n              : _arg$astNode.type,\n          ],\n        );\n      }\n    }\n  }\n}\n\nfunction validateName(context, node) {\n  // Ensure names are valid, however introspection types opt out.\n  if (node.name.startsWith('__')) {\n    context.reportError(\n      `Name \"${node.name}\" must not begin with \"__\", which is reserved by GraphQL introspection.`,\n      node.astNode,\n    );\n  }\n}\n\nfunction validateTypes(context) {\n  const validateInputObjectCircularRefs =\n    createInputObjectCircularRefsValidator(context);\n  const typeMap = context.schema.getTypeMap();\n\n  for (const type of Object.values(typeMap)) {\n    // Ensure all provided types are in fact GraphQL type.\n    if (!isNamedType(type)) {\n      context.reportError(\n        `Expected GraphQL named type but got: ${inspect(type)}.`,\n        type.astNode,\n      );\n      continue;\n    } // Ensure it is named correctly (excluding introspection types).\n\n    if (!isIntrospectionType(type)) {\n      validateName(context, type);\n    }\n\n    if (isObjectType(type)) {\n      // Ensure fields are valid\n      validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isInterfaceType(type)) {\n      // Ensure fields are valid.\n      validateFields(context, type); // Ensure interfaces implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isUnionType(type)) {\n      // Ensure Unions include valid member types.\n      validateUnionMembers(context, type);\n    } else if (isEnumType(type)) {\n      // Ensure Enums have valid values.\n      validateEnumValues(context, type);\n    } else if (isInputObjectType(type)) {\n      // Ensure Input Object fields are valid.\n      validateInputFields(context, type); // Ensure Input Objects do not contain non-nullable circular references\n\n      validateInputObjectCircularRefs(type);\n    }\n  }\n}\n\nfunction validateFields(context, type) {\n  const fields = Object.values(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(`Type ${type.name} must define one or more fields.`, [\n      type.astNode,\n      ...type.extensionASTNodes,\n    ]);\n  }\n\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an output type\n\n    if (!isOutputType(field.type)) {\n      var _field$astNode;\n\n      context.reportError(\n        `The type of ${type.name}.${field.name} must be Output Type ` +\n          `but got: ${inspect(field.type)}.`,\n        (_field$astNode = field.astNode) === null || _field$astNode === void 0\n          ? void 0\n          : _field$astNode.type,\n      );\n    } // Ensure the arguments are valid\n\n    for (const arg of field.args) {\n      const argName = arg.name; // Ensure they are named correctly.\n\n      validateName(context, arg); // Ensure the type is an input type\n\n      if (!isInputType(arg.type)) {\n        var _arg$astNode2;\n\n        context.reportError(\n          `The type of ${type.name}.${field.name}(${argName}:) must be Input ` +\n            `Type but got: ${inspect(arg.type)}.`,\n          (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0\n            ? void 0\n            : _arg$astNode2.type,\n        );\n      }\n\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        var _arg$astNode3;\n\n        context.reportError(\n          `Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`,\n          [\n            getDeprecatedDirectiveNode(arg.astNode),\n            (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0\n              ? void 0\n              : _arg$astNode3.type,\n          ],\n        );\n      }\n    }\n  }\n}\n\nfunction validateInterfaces(context, type) {\n  const ifaceTypeNames = Object.create(null);\n\n  for (const iface of type.getInterfaces()) {\n    if (!isInterfaceType(iface)) {\n      context.reportError(\n        `Type ${inspect(type)} must only implement Interface types, ` +\n          `it cannot implement ${inspect(iface)}.`,\n        getAllImplementsInterfaceNodes(type, iface),\n      );\n      continue;\n    }\n\n    if (type === iface) {\n      context.reportError(\n        `Type ${type.name} cannot implement itself because it would create a circular reference.`,\n        getAllImplementsInterfaceNodes(type, iface),\n      );\n      continue;\n    }\n\n    if (ifaceTypeNames[iface.name]) {\n      context.reportError(\n        `Type ${type.name} can only implement ${iface.name} once.`,\n        getAllImplementsInterfaceNodes(type, iface),\n      );\n      continue;\n    }\n\n    ifaceTypeNames[iface.name] = true;\n    validateTypeImplementsAncestors(context, type, iface);\n    validateTypeImplementsInterface(context, type, iface);\n  }\n}\n\nfunction validateTypeImplementsInterface(context, type, iface) {\n  const typeFieldMap = type.getFields(); // Assert each interface field is implemented.\n\n  for (const ifaceField of Object.values(iface.getFields())) {\n    const fieldName = ifaceField.name;\n    const typeField = typeFieldMap[fieldName]; // Assert interface field exists on type.\n\n    if (!typeField) {\n      context.reportError(\n        `Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`,\n        [ifaceField.astNode, type.astNode, ...type.extensionASTNodes],\n      );\n      continue;\n    } // Assert interface field type is satisfied by type field type, by being\n    // a valid subtype. (covariant)\n\n    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {\n      var _ifaceField$astNode, _typeField$astNode;\n\n      context.reportError(\n        `Interface field ${iface.name}.${fieldName} expects type ` +\n          `${inspect(ifaceField.type)} but ${type.name}.${fieldName} ` +\n          `is type ${inspect(typeField.type)}.`,\n        [\n          (_ifaceField$astNode = ifaceField.astNode) === null ||\n          _ifaceField$astNode === void 0\n            ? void 0\n            : _ifaceField$astNode.type,\n          (_typeField$astNode = typeField.astNode) === null ||\n          _typeField$astNode === void 0\n            ? void 0\n            : _typeField$astNode.type,\n        ],\n      );\n    } // Assert each interface field arg is implemented.\n\n    for (const ifaceArg of ifaceField.args) {\n      const argName = ifaceArg.name;\n      const typeArg = typeField.args.find((arg) => arg.name === argName); // Assert interface field arg exists on object field.\n\n      if (!typeArg) {\n        context.reportError(\n          `Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`,\n          [ifaceArg.astNode, typeField.astNode],\n        );\n        continue;\n      } // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      // TODO: change to contravariant?\n\n      if (!isEqualType(ifaceArg.type, typeArg.type)) {\n        var _ifaceArg$astNode, _typeArg$astNode;\n\n        context.reportError(\n          `Interface field argument ${iface.name}.${fieldName}(${argName}:) ` +\n            `expects type ${inspect(ifaceArg.type)} but ` +\n            `${type.name}.${fieldName}(${argName}:) is type ` +\n            `${inspect(typeArg.type)}.`,\n          [\n            // istanbul ignore next (TODO need to write coverage tests)\n            (_ifaceArg$astNode = ifaceArg.astNode) === null ||\n            _ifaceArg$astNode === void 0\n              ? void 0\n              : _ifaceArg$astNode.type, // istanbul ignore next (TODO need to write coverage tests)\n            (_typeArg$astNode = typeArg.astNode) === null ||\n            _typeArg$astNode === void 0\n              ? void 0\n              : _typeArg$astNode.type,\n          ],\n        );\n      } // TODO: validate default values?\n    } // Assert additional arguments must not be required.\n\n    for (const typeArg of typeField.args) {\n      const argName = typeArg.name;\n      const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);\n\n      if (!ifaceArg && isRequiredArgument(typeArg)) {\n        context.reportError(\n          `Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`,\n          [typeArg.astNode, ifaceField.astNode],\n        );\n      }\n    }\n  }\n}\n\nfunction validateTypeImplementsAncestors(context, type, iface) {\n  const ifaceInterfaces = type.getInterfaces();\n\n  for (const transitive of iface.getInterfaces()) {\n    if (!ifaceInterfaces.includes(transitive)) {\n      context.reportError(\n        transitive === type\n          ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.`\n          : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`,\n        [\n          ...getAllImplementsInterfaceNodes(iface, transitive),\n          ...getAllImplementsInterfaceNodes(type, iface),\n        ],\n      );\n    }\n  }\n}\n\nfunction validateUnionMembers(context, union) {\n  const memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError(\n      `Union type ${union.name} must define one or more member types.`,\n      [union.astNode, ...union.extensionASTNodes],\n    );\n  }\n\n  const includedTypeNames = Object.create(null);\n\n  for (const memberType of memberTypes) {\n    if (includedTypeNames[memberType.name]) {\n      context.reportError(\n        `Union type ${union.name} can only include type ${memberType.name} once.`,\n        getUnionMemberTypeNodes(union, memberType.name),\n      );\n      continue;\n    }\n\n    includedTypeNames[memberType.name] = true;\n\n    if (!isObjectType(memberType)) {\n      context.reportError(\n        `Union type ${union.name} can only include Object types, ` +\n          `it cannot include ${inspect(memberType)}.`,\n        getUnionMemberTypeNodes(union, String(memberType)),\n      );\n    }\n  }\n}\n\nfunction validateEnumValues(context, enumType) {\n  const enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError(\n      `Enum type ${enumType.name} must define one or more values.`,\n      [enumType.astNode, ...enumType.extensionASTNodes],\n    );\n  }\n\n  for (const enumValue of enumValues) {\n    // Ensure valid name.\n    validateName(context, enumValue);\n  }\n}\n\nfunction validateInputFields(context, inputObj) {\n  const fields = Object.values(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError(\n      `Input Object type ${inputObj.name} must define one or more fields.`,\n      [inputObj.astNode, ...inputObj.extensionASTNodes],\n    );\n  } // Ensure the arguments are valid\n\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an input type\n\n    if (!isInputType(field.type)) {\n      var _field$astNode2;\n\n      context.reportError(\n        `The type of ${inputObj.name}.${field.name} must be Input Type ` +\n          `but got: ${inspect(field.type)}.`,\n        (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0\n          ? void 0\n          : _field$astNode2.type,\n      );\n    }\n\n    if (isRequiredInputField(field) && field.deprecationReason != null) {\n      var _field$astNode3;\n\n      context.reportError(\n        `Required input field ${inputObj.name}.${field.name} cannot be deprecated.`,\n        [\n          getDeprecatedDirectiveNode(field.astNode), // istanbul ignore next (TODO need to write coverage tests)\n          (_field$astNode3 = field.astNode) === null ||\n          _field$astNode3 === void 0\n            ? void 0\n            : _field$astNode3.type,\n        ],\n      );\n    }\n  }\n}\n\nfunction createInputObjectCircularRefsValidator(context) {\n  // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.\n  // Tracks already visited types to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  const visitedTypes = Object.create(null); // Array of types nodes used to produce meaningful errors\n\n  const fieldPath = []; // Position in the type path\n\n  const fieldPathIndexByTypeName = Object.create(null);\n  return detectCycleRecursive; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(inputObj) {\n    if (visitedTypes[inputObj.name]) {\n      return;\n    }\n\n    visitedTypes[inputObj.name] = true;\n    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;\n    const fields = Object.values(inputObj.getFields());\n\n    for (const field of fields) {\n      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {\n        const fieldType = field.type.ofType;\n        const cycleIndex = fieldPathIndexByTypeName[fieldType.name];\n        fieldPath.push(field);\n\n        if (cycleIndex === undefined) {\n          detectCycleRecursive(fieldType);\n        } else {\n          const cyclePath = fieldPath.slice(cycleIndex);\n          const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join('.');\n          context.reportError(\n            `Cannot reference Input Object \"${fieldType.name}\" within itself through a series of non-null fields: \"${pathStr}\".`,\n            cyclePath.map((fieldObj) => fieldObj.astNode),\n          );\n        }\n\n        fieldPath.pop();\n      }\n    }\n\n    fieldPathIndexByTypeName[inputObj.name] = undefined;\n  }\n}\n\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  const { astNode, extensionASTNodes } = type;\n  const nodes =\n    astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n  return nodes\n    .flatMap((typeNode) => {\n      var _typeNode$interfaces;\n\n      return (_typeNode$interfaces = typeNode.interfaces) !== null &&\n        _typeNode$interfaces !== void 0\n        ? _typeNode$interfaces\n        : [];\n    })\n    .filter((ifaceNode) => ifaceNode.name.value === iface.name);\n}\n\nfunction getUnionMemberTypeNodes(union, typeName) {\n  const { astNode, extensionASTNodes } = union;\n  const nodes =\n    astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n  return nodes\n    .flatMap((unionNode) => {\n      var _unionNode$types;\n\n      return (_unionNode$types = unionNode.types) !== null &&\n        _unionNode$types !== void 0\n        ? _unionNode$types\n        : [];\n    })\n    .filter((typeNode) => typeNode.name.value === typeName);\n}\n\nfunction getDeprecatedDirectiveNode(definitionNode) {\n  var _definitionNode$direc;\n\n  // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n  return definitionNode === null || definitionNode === void 0\n    ? void 0\n    : (_definitionNode$direc = definitionNode.directives) === null ||\n      _definitionNode$direc === void 0\n    ? void 0\n    : _definitionNode$direc.find(\n        (node) => node.name.value === GraphQLDeprecatedDirective.name,\n      );\n}\n"]},"metadata":{},"sourceType":"module"}