{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { invariant, InvariantError } from \"../../utilities/globals/index.js\";\nimport { wrap } from 'optimism';\nimport { isField, resultKeyNameFromField, isReference, makeReference, createFragmentMap, shouldInclude, addTypenameToDocument, getDefaultValues, getFragmentDefinitions, getMainDefinition, getQueryDefinition, mergeDeepArray, getFragmentFromSelection, maybeDeepFreeze, isNonNullObject, canUseWeakMap, compact } from \"../../utilities/index.js\";\nimport { maybeDependOnExistenceOfEntity, supportsResultCaching } from \"./entityStore.js\";\nimport { getTypenameFromStoreObject, shouldCanonizeResults } from \"./helpers.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport { canonicalStringify, ObjectCanon } from \"./object-canon.js\";\n;\n\nfunction missingFromInvariant(err, context) {\n  return new MissingFieldError(err.message, context.path.slice(), context.query, context.variables);\n}\n\nfunction execSelectionSetKeyArgs(options) {\n  return [options.selectionSet, options.objectOrReference, options.context, options.context.canonizeResults];\n}\n\nvar StoreReader = function () {\n  function StoreReader(config) {\n    var _this = this;\n\n    this.knownResults = new (canUseWeakMap ? WeakMap : Map)();\n    this.config = compact(config, {\n      addTypename: config.addTypename !== false,\n      canonizeResults: shouldCanonizeResults(config)\n    });\n    this.canon = config.canon || new ObjectCanon();\n    this.executeSelectionSet = wrap(function (options) {\n      var _a;\n\n      var canonizeResults = options.context.canonizeResults;\n      var peekArgs = execSelectionSetKeyArgs(options);\n      peekArgs[3] = !canonizeResults;\n\n      var other = (_a = _this.executeSelectionSet).peek.apply(_a, peekArgs);\n\n      if (other) {\n        if (canonizeResults) {\n          return __assign(__assign({}, other), {\n            result: _this.canon.admit(other.result)\n          });\n        }\n\n        return other;\n      }\n\n      maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);\n      return _this.execSelectionSetImpl(options);\n    }, {\n      max: this.config.resultCacheMaxSize,\n      keyArgs: execSelectionSetKeyArgs,\n      makeCacheKey: function (selectionSet, parent, context, canonizeResults) {\n        if (supportsResultCaching(context.store)) {\n          return context.store.makeCacheKey(selectionSet, isReference(parent) ? parent.__ref : parent, context.varString, canonizeResults);\n        }\n      }\n    });\n    this.executeSubSelectedArray = wrap(function (options) {\n      maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);\n      return _this.execSubSelectedArrayImpl(options);\n    }, {\n      max: this.config.resultCacheMaxSize,\n      makeCacheKey: function (_a) {\n        var field = _a.field,\n            array = _a.array,\n            context = _a.context;\n\n        if (supportsResultCaching(context.store)) {\n          return context.store.makeCacheKey(field, array, context.varString);\n        }\n      }\n    });\n  }\n\n  StoreReader.prototype.resetCanon = function () {\n    this.canon = new ObjectCanon();\n  };\n\n  StoreReader.prototype.diffQueryAgainstStore = function (_a) {\n    var store = _a.store,\n        query = _a.query,\n        _b = _a.rootId,\n        rootId = _b === void 0 ? 'ROOT_QUERY' : _b,\n        variables = _a.variables,\n        _c = _a.returnPartialData,\n        returnPartialData = _c === void 0 ? true : _c,\n        _d = _a.canonizeResults,\n        canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;\n    var policies = this.config.cache.policies;\n    variables = __assign(__assign({}, getDefaultValues(getQueryDefinition(query))), variables);\n    var rootRef = makeReference(rootId);\n    var execResult = this.executeSelectionSet({\n      selectionSet: getMainDefinition(query).selectionSet,\n      objectOrReference: rootRef,\n      enclosingRef: rootRef,\n      context: {\n        store: store,\n        query: query,\n        policies: policies,\n        variables: variables,\n        varString: canonicalStringify(variables),\n        canonizeResults: canonizeResults,\n        fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n        path: []\n      }\n    });\n    var hasMissingFields = execResult.missing && execResult.missing.length > 0;\n\n    if (hasMissingFields && !returnPartialData) {\n      throw execResult.missing[0];\n    }\n\n    return {\n      result: execResult.result,\n      missing: execResult.missing,\n      complete: !hasMissingFields\n    };\n  };\n\n  StoreReader.prototype.isFresh = function (result, parent, selectionSet, context) {\n    if (supportsResultCaching(context.store) && this.knownResults.get(result) === selectionSet) {\n      var latest = this.executeSelectionSet.peek(selectionSet, parent, context, this.canon.isKnown(result));\n\n      if (latest && result === latest.result) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  StoreReader.prototype.execSelectionSetImpl = function (_a) {\n    var _this = this;\n\n    var selectionSet = _a.selectionSet,\n        objectOrReference = _a.objectOrReference,\n        enclosingRef = _a.enclosingRef,\n        context = _a.context;\n\n    if (isReference(objectOrReference) && !context.policies.rootTypenamesById[objectOrReference.__ref] && !context.store.has(objectOrReference.__ref)) {\n      return {\n        result: this.canon.empty,\n        missing: [missingFromInvariant(__DEV__ ? new InvariantError(\"Dangling reference to missing \" + objectOrReference.__ref + \" object\") : new InvariantError(5), context)]\n      };\n    }\n\n    var variables = context.variables,\n        policies = context.policies,\n        store = context.store;\n    var objectsToMerge = [];\n    var finalResult = {\n      result: null\n    };\n    var typename = store.getFieldValue(objectOrReference, \"__typename\");\n\n    if (this.config.addTypename && typeof typename === \"string\" && !policies.rootIdsByTypename[typename]) {\n      objectsToMerge.push({\n        __typename: typename\n      });\n    }\n\n    function getMissing() {\n      return finalResult.missing || (finalResult.missing = []);\n    }\n\n    function handleMissing(result) {\n      var _a;\n\n      if (result.missing) (_a = getMissing()).push.apply(_a, result.missing);\n      return result.result;\n    }\n\n    var workSet = new Set(selectionSet.selections);\n    workSet.forEach(function (selection) {\n      var _a;\n\n      if (!shouldInclude(selection, variables)) return;\n\n      if (isField(selection)) {\n        var fieldValue = policies.readField({\n          fieldName: selection.name.value,\n          field: selection,\n          variables: context.variables,\n          from: objectOrReference\n        }, context);\n        var resultName = resultKeyNameFromField(selection);\n        context.path.push(resultName);\n\n        if (fieldValue === void 0) {\n          if (!addTypenameToDocument.added(selection)) {\n            getMissing().push(missingFromInvariant(__DEV__ ? new InvariantError(\"Can't find field '\" + selection.name.value + \"' on \" + (isReference(objectOrReference) ? objectOrReference.__ref + \" object\" : \"object \" + JSON.stringify(objectOrReference, null, 2))) : new InvariantError(6), context));\n          }\n        } else if (Array.isArray(fieldValue)) {\n          fieldValue = handleMissing(_this.executeSubSelectedArray({\n            field: selection,\n            array: fieldValue,\n            enclosingRef: enclosingRef,\n            context: context\n          }));\n        } else if (!selection.selectionSet) {\n          if (context.canonizeResults) {\n            fieldValue = _this.canon.pass(fieldValue);\n          }\n        } else if (fieldValue != null) {\n          fieldValue = handleMissing(_this.executeSelectionSet({\n            selectionSet: selection.selectionSet,\n            objectOrReference: fieldValue,\n            enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,\n            context: context\n          }));\n        }\n\n        if (fieldValue !== void 0) {\n          objectsToMerge.push((_a = {}, _a[resultName] = fieldValue, _a));\n        }\n\n        invariant(context.path.pop() === resultName);\n      } else {\n        var fragment = getFragmentFromSelection(selection, context.fragmentMap);\n\n        if (fragment && policies.fragmentMatches(fragment, typename)) {\n          fragment.selectionSet.selections.forEach(workSet.add, workSet);\n        }\n      }\n    });\n    var merged = mergeDeepArray(objectsToMerge);\n    finalResult.result = context.canonizeResults ? this.canon.admit(merged) : maybeDeepFreeze(merged);\n    this.knownResults.set(finalResult.result, selectionSet);\n    return finalResult;\n  };\n\n  StoreReader.prototype.execSubSelectedArrayImpl = function (_a) {\n    var _this = this;\n\n    var field = _a.field,\n        array = _a.array,\n        enclosingRef = _a.enclosingRef,\n        context = _a.context;\n    var missing;\n\n    function handleMissing(childResult, i) {\n      if (childResult.missing) {\n        missing = missing || [];\n        missing.push.apply(missing, childResult.missing);\n      }\n\n      invariant(context.path.pop() === i);\n      return childResult.result;\n    }\n\n    if (field.selectionSet) {\n      array = array.filter(context.store.canRead);\n    }\n\n    array = array.map(function (item, i) {\n      if (item === null) {\n        return null;\n      }\n\n      context.path.push(i);\n\n      if (Array.isArray(item)) {\n        return handleMissing(_this.executeSubSelectedArray({\n          field: field,\n          array: item,\n          enclosingRef: enclosingRef,\n          context: context\n        }), i);\n      }\n\n      if (field.selectionSet) {\n        return handleMissing(_this.executeSelectionSet({\n          selectionSet: field.selectionSet,\n          objectOrReference: item,\n          enclosingRef: isReference(item) ? item : enclosingRef,\n          context: context\n        }), i);\n      }\n\n      if (__DEV__) {\n        assertSelectionSetForIdValue(context.store, field, item);\n      }\n\n      invariant(context.path.pop() === i);\n      return item;\n    });\n    return {\n      result: context.canonizeResults ? this.canon.admit(array) : array,\n      missing: missing\n    };\n  };\n\n  return StoreReader;\n}();\n\nexport { StoreReader };\n\nfunction assertSelectionSetForIdValue(store, field, fieldValue) {\n  if (!field.selectionSet) {\n    var workSet_1 = new Set([fieldValue]);\n    workSet_1.forEach(function (value) {\n      if (isNonNullObject(value)) {\n        __DEV__ ? invariant(!isReference(value), \"Missing selection set for object of type \" + getTypenameFromStoreObject(store, value) + \" returned for query field \" + field.name.value) : invariant(!isReference(value), 7);\n        Object.values(value).forEach(workSet_1.add, workSet_1);\n      }\n    });\n  }\n}","map":{"version":3,"sources":["../../../src/cache/inmemory/readFromStore.ts"],"names":[],"mappings":";AAAA,SAAS,SAAT,EAAoB,cAApB,QAA0C,kCAA1C;AAOA,SAAS,IAAT,QAAgD,UAAhD;AAEA,SACE,OADF,EAEE,sBAFF,EAIE,WAJF,EAKE,aALF,EAOE,iBAPF,EASE,aATF,EAUE,qBAVF,EAWE,gBAXF,EAYE,sBAZF,EAaE,iBAbF,EAcE,kBAdF,EAeE,cAfF,EAgBE,wBAhBF,EAiBE,eAjBF,EAkBE,eAlBF,EAmBE,aAnBF,EAoBE,OApBF,QAqBO,0BArBP;AA4BA,SAAS,8BAAT,EAAyC,qBAAzC,QAAsE,kBAAtE;AACA,SAAS,0BAAT,EAAqC,qBAArC,QAAkE,cAAlE;AAGA,SAAS,iBAAT,QAAkC,yBAAlC;AACA,SAAS,kBAAT,EAA6B,WAA7B,QAAgD,mBAAhD;AAUC;;AAOD,SAAS,oBAAT,CACE,GADF,EAEE,OAFF,EAEsB;AAEpB,SAAO,IAAI,iBAAJ,CACL,GAAG,CAAC,OADC,EAEL,OAAO,CAAC,IAAR,CAAa,KAAb,EAFK,EAGL,OAAO,CAAC,KAHH,EAIL,OAAO,CAAC,SAJH,CAAP;AAMD;;AAgCD,SAAS,uBAAT,CACE,OADF,EACkC;AAEhC,SAAO,CACL,OAAO,CAAC,YADH,EAEL,OAAO,CAAC,iBAFH,EAGL,OAAO,CAAC,OAHH,EAML,OAAO,CAAC,OAAR,CAAgB,eANX,CAAP;AAQD;;AAED,IAAA,WAAA,GAAA,YAAA;AA8BE,WAAA,WAAA,CAAY,MAAZ,EAAqC;AAArC,QAAA,KAAA,GAAA,IAAA;;AATQ,SAAA,YAAA,GAAe,KACrB,aAAa,GAAG,OAAH,GAAa,GADL,GAAf;AAUN,SAAK,MAAL,GAAc,OAAO,CAAC,MAAD,EAAS;AAC5B,MAAA,WAAW,EAAE,MAAM,CAAC,WAAP,KAAuB,KADR;AAE5B,MAAA,eAAe,EAAE,qBAAqB,CAAC,MAAD;AAFV,KAAT,CAArB;AAKA,SAAK,KAAL,GAAa,MAAM,CAAC,KAAP,IAAgB,IAAI,WAAJ,EAA7B;AAEA,SAAK,mBAAL,GAA2B,IAAI,CAAC,UAAA,OAAA,EAAO;;;AAC7B,UAAA,eAAe,GAAK,OAAO,CAAC,OAAR,CAAL,eAAf;AAER,UAAM,QAAQ,GAAG,uBAAuB,CAAC,OAAD,CAAxC;AAIA,MAAA,QAAQ,CAAC,CAAD,CAAR,GAAc,CAAC,eAAf;;AAEA,UAAM,KAAK,GAAG,CAAA,EAAA,GAAA,KAAI,CAAC,mBAAL,EAAyB,IAAzB,CAA6B,KAA7B,CAA6B,EAA7B,EAAiC,QAAjC,CAAd;;AAEA,UAAI,KAAJ,EAAW;AACT,YAAI,eAAJ,EAAqB;AACnB,iBAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EACK,KADL,CAAA,EACU;AAGR,YAAA,MAAM,EAAE,KAAI,CAAC,KAAL,CAAW,KAAX,CAAiB,KAAK,CAAC,MAAvB;AAHA,WADV,CAAA;AAMD;;AAGD,eAAO,KAAP;AACD;;AAED,MAAA,8BAA8B,CAC5B,OAAO,CAAC,OAAR,CAAgB,KADY,EAE5B,OAAO,CAAC,YAAR,CAAqB,KAFO,CAA9B;AAOA,aAAO,KAAI,CAAC,oBAAL,CAA0B,OAA1B,CAAP;AAED,KAlC8B,EAkC5B;AACD,MAAA,GAAG,EAAE,KAAK,MAAL,CAAY,kBADhB;AAED,MAAA,OAAO,EAAE,uBAFR;AAKD,MAAA,YAAY,EAAA,UAAC,YAAD,EAAe,MAAf,EAAuB,OAAvB,EAAgC,eAAhC,EAA+C;AACzD,YAAI,qBAAqB,CAAC,OAAO,CAAC,KAAT,CAAzB,EAA0C;AACxC,iBAAO,OAAO,CAAC,KAAR,CAAc,YAAd,CACL,YADK,EAEL,WAAW,CAAC,MAAD,CAAX,GAAsB,MAAM,CAAC,KAA7B,GAAqC,MAFhC,EAGL,OAAO,CAAC,SAHH,EAIL,eAJK,CAAP;AAMD;AACF;AAdA,KAlC4B,CAA/B;AAmDA,SAAK,uBAAL,GAA+B,IAAI,CAAC,UAAC,OAAD,EAAqC;AACvE,MAAA,8BAA8B,CAC5B,OAAO,CAAC,OAAR,CAAgB,KADY,EAE5B,OAAO,CAAC,YAAR,CAAqB,KAFO,CAA9B;AAIA,aAAO,KAAI,CAAC,wBAAL,CAA8B,OAA9B,CAAP;AACD,KANkC,EAMhC;AACD,MAAA,GAAG,EAAE,KAAK,MAAL,CAAY,kBADhB;AAED,MAAA,YAAY,EAAA,UAAC,EAAD,EAA0B;YAAvB,KAAK,GAAA,EAAA,CAAA,K;YAAE,KAAK,GAAA,EAAA,CAAA,K;YAAE,OAAO,GAAA,EAAA,CAAA,O;;AAClC,YAAI,qBAAqB,CAAC,OAAO,CAAC,KAAT,CAAzB,EAA0C;AACxC,iBAAO,OAAO,CAAC,KAAR,CAAc,YAAd,CACL,KADK,EAEL,KAFK,EAGL,OAAO,CAAC,SAHH,CAAP;AAKD;AACF;AAVA,KANgC,CAAnC;AAkBD;;AAjFM,EAAA,WAAA,CAAA,SAAA,CAAA,UAAA,GAAP,YAAA;AACE,SAAK,KAAL,GAAa,IAAI,WAAJ,EAAb;AACD,GAFM;;AA0FA,EAAA,WAAA,CAAA,SAAA,CAAA,qBAAA,GAAP,UAAgC,EAAhC,EAO+B;QAN7B,KAAK,GAAA,EAAA,CAAA,K;QACL,KAAK,GAAA,EAAA,CAAA,K;QACL,EAAA,GAAA,EAAA,CAAA,M;QAAA,MAAM,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,YAAH,GAAe,E;QACrB,SAAS,GAAA,EAAA,CAAA,S;QACT,EAAA,GAAA,EAAA,CAAA,iB;QAAA,iBAAiB,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,IAAH,GAAO,E;QACxB,EAAA,GAAA,EAAA,CAAA,e;QAAA,eAAe,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,KAAK,MAAL,CAAY,eAAf,GAA8B,E;AAE7C,QAAM,QAAQ,GAAG,KAAK,MAAL,CAAY,KAAZ,CAAkB,QAAnC;AAEA,IAAA,SAAS,GAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EACJ,gBAAgB,CAAC,kBAAkB,CAAC,KAAD,CAAnB,CADZ,CAAA,EAEJ,SAFI,CAAT;AAKA,QAAM,OAAO,GAAG,aAAa,CAAC,MAAD,CAA7B;AACA,QAAM,UAAU,GAAG,KAAK,mBAAL,CAAyB;AAC1C,MAAA,YAAY,EAAE,iBAAiB,CAAC,KAAD,CAAjB,CAAyB,YADG;AAE1C,MAAA,iBAAiB,EAAE,OAFuB;AAG1C,MAAA,YAAY,EAAE,OAH4B;AAI1C,MAAA,OAAO,EAAE;AACP,QAAA,KAAK,EAAA,KADE;AAEP,QAAA,KAAK,EAAA,KAFE;AAGP,QAAA,QAAQ,EAAA,QAHD;AAIP,QAAA,SAAS,EAAA,SAJF;AAKP,QAAA,SAAS,EAAE,kBAAkB,CAAC,SAAD,CALtB;AAMP,QAAA,eAAe,EAAA,eANR;AAOP,QAAA,WAAW,EAAE,iBAAiB,CAAC,sBAAsB,CAAC,KAAD,CAAvB,CAPvB;AAQP,QAAA,IAAI,EAAE;AARC;AAJiC,KAAzB,CAAnB;AAgBA,QAAM,gBAAgB,GACpB,UAAU,CAAC,OAAX,IAAsB,UAAU,CAAC,OAAX,CAAmB,MAAnB,GAA4B,CADpD;;AAEA,QAAI,gBAAgB,IAAI,CAAC,iBAAzB,EAA4C;AAC1C,YAAM,UAAU,CAAC,OAAX,CAAoB,CAApB,CAAN;AACD;;AAED,WAAO;AACL,MAAA,MAAM,EAAE,UAAU,CAAC,MADd;AAEL,MAAA,OAAO,EAAE,UAAU,CAAC,OAFf;AAGL,MAAA,QAAQ,EAAE,CAAC;AAHN,KAAP;AAKD,GA3CM;;AA6CA,EAAA,WAAA,CAAA,SAAA,CAAA,OAAA,GAAP,UACE,MADF,EAEE,MAFF,EAGE,YAHF,EAIE,OAJF,EAIiC;AAE/B,QAAI,qBAAqB,CAAC,OAAO,CAAC,KAAT,CAArB,IACA,KAAK,YAAL,CAAkB,GAAlB,CAAsB,MAAtB,MAAkC,YADtC,EACoD;AAClD,UAAM,MAAM,GAAG,KAAK,mBAAL,CAAyB,IAAzB,CACb,YADa,EAEb,MAFa,EAGb,OAHa,EAOb,KAAK,KAAL,CAAW,OAAX,CAAmB,MAAnB,CAPa,CAAf;;AASA,UAAI,MAAM,IAAI,MAAM,KAAK,MAAM,CAAC,MAAhC,EAAwC;AACtC,eAAO,IAAP;AACD;AACF;;AACD,WAAO,KAAP;AACD,GAtBM;;AAyBC,EAAA,WAAA,CAAA,SAAA,CAAA,oBAAA,GAAR,UAA6B,EAA7B,EAK0B;AAL1B,QAAA,KAAA,GAAA,IAAA;;QACE,YAAY,GAAA,EAAA,CAAA,Y;QACZ,iBAAiB,GAAA,EAAA,CAAA,iB;QACjB,YAAY,GAAA,EAAA,CAAA,Y;QACZ,OAAO,GAAA,EAAA,CAAA,O;;AAEP,QAAI,WAAW,CAAC,iBAAD,CAAX,IACA,CAAC,OAAO,CAAC,QAAR,CAAiB,iBAAjB,CAAmC,iBAAiB,CAAC,KAArD,CADD,IAEA,CAAC,OAAO,CAAC,KAAR,CAAc,GAAd,CAAkB,iBAAiB,CAAC,KAApC,CAFL,EAEiD;AAC/C,aAAO;AACL,QAAA,MAAM,EAAE,KAAK,KAAL,CAAW,KADd;AAEL,QAAA,OAAO,EAAE,CAAC,oBAAoB,CAC5B,OAAI,GAAA,IAAA,cAAA,CACF,mCAAiC,iBAAuB,CAAA,KAAxD,GACD,SAFG,CAAA,GAIJ,IAAA,cAAA,CAAA,CAAA,CAL4B,EAK5B,OAL4B,CAArB;AAFJ,OAAP;AASD;;AAEO,QAAA,SAAS,GAAsB,OAAO,CAA7B,SAAT;AAAA,QAAW,QAAQ,GAAY,OAAO,CAAnB,QAAnB;AAAA,QAAqB,KAAK,GAAK,OAAO,CAAZ,KAA1B;AACR,QAAM,cAAc,GAA6B,EAAjD;AACA,QAAM,WAAW,GAAe;AAAE,MAAA,MAAM,EAAE;AAAV,KAAhC;AACA,QAAM,QAAQ,GAAG,KAAK,CAAC,aAAN,CAA4B,iBAA5B,EAA+C,YAA/C,CAAjB;;AAEA,QAAI,KAAK,MAAL,CAAY,WAAZ,IACA,OAAO,QAAP,KAAoB,QADpB,IAEA,CAAC,QAAQ,CAAC,iBAAT,CAA2B,QAA3B,CAFL,EAE2C;AAIzC,MAAA,cAAc,CAAC,IAAf,CAAoB;AAAE,QAAA,UAAU,EAAE;AAAd,OAApB;AACD;;AAED,aAAS,UAAT,GAAmB;AACjB,aAAO,WAAW,CAAC,OAAZ,KAAwB,WAAW,CAAC,OAAZ,GAAsB,EAA9C,CAAP;AACD;;AAED,aAAS,aAAT,CAA0B,MAA1B,EAA+C;;;AAC7C,UAAI,MAAM,CAAC,OAAX,EAAoB,CAAA,EAAA,GAAA,UAAU,EAAV,EAAa,IAAb,CAAiB,KAAjB,CAAiB,EAAjB,EAAqB,MAAM,CAAC,OAA5B;AACpB,aAAO,MAAM,CAAC,MAAd;AACD;;AAED,QAAM,OAAO,GAAG,IAAI,GAAJ,CAAQ,YAAY,CAAC,UAArB,CAAhB;AAEA,IAAA,OAAO,CAAC,OAAR,CAAgB,UAAA,SAAA,EAAS;;;AAGvB,UAAI,CAAC,aAAa,CAAC,SAAD,EAAY,SAAZ,CAAlB,EAA0C;;AAE1C,UAAI,OAAO,CAAC,SAAD,CAAX,EAAwB;AACtB,YAAI,UAAU,GAAG,QAAQ,CAAC,SAAT,CAAmB;AAClC,UAAA,SAAS,EAAE,SAAS,CAAC,IAAV,CAAe,KADQ;AAElC,UAAA,KAAK,EAAE,SAF2B;AAGlC,UAAA,SAAS,EAAE,OAAO,CAAC,SAHe;AAIlC,UAAA,IAAI,EAAE;AAJ4B,SAAnB,EAKd,OALc,CAAjB;AAOA,YAAM,UAAU,GAAG,sBAAsB,CAAC,SAAD,CAAzC;AACA,QAAA,OAAO,CAAC,IAAR,CAAa,IAAb,CAAkB,UAAlB;;AAEA,YAAI,UAAU,KAAK,KAAK,CAAxB,EAA2B;AACzB,cAAI,CAAC,qBAAqB,CAAC,KAAtB,CAA4B,SAA5B,CAAL,EAA6C;AAC3C,YAAA,UAAU,GAAG,IAAb,CACE,oBAAoB,CAClB,OAAI,GAAA,IAAA,cAAA,CAAe,uBACP,SAAK,CAAK,IAAV,CAAU,KADH,GACG,OADH,IAGjB,WAAY,CAAA,iBAAA,CAAZ,GACI,iBAAiB,CAAC,KAAlB,GAA0B,SAD9B,GAEI,YAAY,IAAI,CAAC,SAAL,CAAe,iBAAf,EAAkC,IAAlC,EAAwC,CAAxC,CALC,CAAf,CAAA,GAOJ,IAAA,cAAA,CAEF,CAFE,CARkB,EAUpB,OAVoB,CADtB;AAYD;AAEF,SAhBD,MAgBO,IAAI,KAAK,CAAC,OAAN,CAAc,UAAd,CAAJ,EAA+B;AACpC,UAAA,UAAU,GAAG,aAAa,CAAC,KAAI,CAAC,uBAAL,CAA6B;AACtD,YAAA,KAAK,EAAE,SAD+C;AAEtD,YAAA,KAAK,EAAE,UAF+C;AAGtD,YAAA,YAAY,EAAA,YAH0C;AAItD,YAAA,OAAO,EAAA;AAJ+C,WAA7B,CAAD,CAA1B;AAOD,SARM,MAQA,IAAI,CAAC,SAAS,CAAC,YAAf,EAA6B;AAKlC,cAAI,OAAO,CAAC,eAAZ,EAA6B;AAC3B,YAAA,UAAU,GAAG,KAAI,CAAC,KAAL,CAAW,IAAX,CAAgB,UAAhB,CAAb;AACD;AAEF,SATM,MASA,IAAI,UAAU,IAAI,IAAlB,EAAwB;AAI7B,UAAA,UAAU,GAAG,aAAa,CAAC,KAAI,CAAC,mBAAL,CAAyB;AAClD,YAAA,YAAY,EAAE,SAAS,CAAC,YAD0B;AAElD,YAAA,iBAAiB,EAAE,UAF+B;AAGlD,YAAA,YAAY,EAAE,WAAW,CAAC,UAAD,CAAX,GAA0B,UAA1B,GAAuC,YAHH;AAIlD,YAAA,OAAO,EAAA;AAJ2C,WAAzB,CAAD,CAA1B;AAMD;;AAED,YAAI,UAAU,KAAK,KAAK,CAAxB,EAA2B;AACzB,UAAA,cAAc,CAAC,IAAf,EAAmB,EAAA,GAAA,EAAA,EAAG,EAAA,CAAC,UAAD,CAAA,GAAc,UAAjB,EAA2B,EAA9C;AACD;;AAED,QAAA,SAAS,CAAC,OAAO,CAAC,IAAR,CAAa,GAAb,OAAuB,UAAxB,CAAT;AAED,OA9DD,MA8DO;AACL,YAAM,QAAQ,GAAG,wBAAwB,CACvC,SADuC,EAEvC,OAAO,CAAC,WAF+B,CAAzC;;AAKA,YAAI,QAAQ,IAAI,QAAQ,CAAC,eAAT,CAAyB,QAAzB,EAAmC,QAAnC,CAAhB,EAA8D;AAC5D,UAAA,QAAQ,CAAC,YAAT,CAAsB,UAAtB,CAAiC,OAAjC,CAAyC,OAAO,CAAC,GAAjD,EAAsD,OAAtD;AACD;AACF;AACF,KA7ED;AAiFA,QAAM,MAAM,GAAG,cAAc,CAAC,cAAD,CAA7B;AACA,IAAA,WAAW,CAAC,MAAZ,GAAqB,OAAO,CAAC,eAAR,GACjB,KAAK,KAAL,CAAW,KAAX,CAAiB,MAAjB,CADiB,GAIjB,eAAe,CAAC,MAAD,CAJnB;AAQA,SAAK,YAAL,CAAkB,GAAlB,CAAsB,WAAW,CAAC,MAAlC,EAA0C,YAA1C;AAEA,WAAO,WAAP;AACD,GA1IO;;AA6IA,EAAA,WAAA,CAAA,SAAA,CAAA,wBAAA,GAAR,UAAiC,EAAjC,EAK8B;AAL9B,QAAA,KAAA,GAAA,IAAA;;QACE,KAAK,GAAA,EAAA,CAAA,K;QACL,KAAK,GAAA,EAAA,CAAA,K;QACL,YAAY,GAAA,EAAA,CAAA,Y;QACZ,OAAO,GAAA,EAAA,CAAA,O;AAEP,QAAI,OAAJ;;AAEA,aAAS,aAAT,CAA0B,WAA1B,EAAsD,CAAtD,EAA+D;AAC7D,UAAI,WAAW,CAAC,OAAhB,EAAyB;AACvB,QAAA,OAAO,GAAG,OAAO,IAAI,EAArB;AACA,QAAA,OAAO,CAAC,IAAR,CAAY,KAAZ,CAAA,OAAA,EAAgB,WAAW,CAAC,OAA5B;AACD;;AAED,MAAA,SAAS,CAAC,OAAO,CAAC,IAAR,CAAa,GAAb,OAAuB,CAAxB,CAAT;AAEA,aAAO,WAAW,CAAC,MAAnB;AACD;;AAED,QAAI,KAAK,CAAC,YAAV,EAAwB;AACtB,MAAA,KAAK,GAAG,KAAK,CAAC,MAAN,CAAa,OAAO,CAAC,KAAR,CAAc,OAA3B,CAAR;AACD;;AAED,IAAA,KAAK,GAAG,KAAK,CAAC,GAAN,CAAU,UAAC,IAAD,EAAO,CAAP,EAAQ;AAExB,UAAI,IAAI,KAAK,IAAb,EAAmB;AACjB,eAAO,IAAP;AACD;;AAED,MAAA,OAAO,CAAC,IAAR,CAAa,IAAb,CAAkB,CAAlB;;AAGA,UAAI,KAAK,CAAC,OAAN,CAAc,IAAd,CAAJ,EAAyB;AACvB,eAAO,aAAa,CAAC,KAAI,CAAC,uBAAL,CAA6B;AAChD,UAAA,KAAK,EAAA,KAD2C;AAEhD,UAAA,KAAK,EAAE,IAFyC;AAGhD,UAAA,YAAY,EAAA,YAHoC;AAIhD,UAAA,OAAO,EAAA;AAJyC,SAA7B,CAAD,EAKhB,CALgB,CAApB;AAMD;;AAGD,UAAI,KAAK,CAAC,YAAV,EAAwB;AACtB,eAAO,aAAa,CAAC,KAAI,CAAC,mBAAL,CAAyB;AAC5C,UAAA,YAAY,EAAE,KAAK,CAAC,YADwB;AAE5C,UAAA,iBAAiB,EAAE,IAFyB;AAG5C,UAAA,YAAY,EAAE,WAAW,CAAC,IAAD,CAAX,GAAoB,IAApB,GAA2B,YAHG;AAI5C,UAAA,OAAO,EAAA;AAJqC,SAAzB,CAAD,EAKhB,CALgB,CAApB;AAMD;;AAED,UAAI,OAAJ,EAAa;AACX,QAAA,4BAA4B,CAAC,OAAO,CAAC,KAAT,EAAgB,KAAhB,EAAuB,IAAvB,CAA5B;AACD;;AAED,MAAA,SAAS,CAAC,OAAO,CAAC,IAAR,CAAa,GAAb,OAAuB,CAAxB,CAAT;AAEA,aAAO,IAAP;AACD,KAnCO,CAAR;AAqCA,WAAO;AACL,MAAA,MAAM,EAAE,OAAO,CAAC,eAAR,GAA0B,KAAK,KAAL,CAAW,KAAX,CAAiB,KAAjB,CAA1B,GAAoD,KADvD;AAEL,MAAA,OAAO,EAAA;AAFF,KAAP;AAID,GAhEO;;AAiEV,SAAA,WAAA;AAAC,CAxYD,EAAA;;;;AA0YA,SAAS,4BAAT,CACE,KADF,EAEE,KAFF,EAGE,UAHF,EAGiB;AAEf,MAAI,CAAC,KAAK,CAAC,YAAX,EAAyB;AACvB,QAAM,SAAO,GAAG,IAAI,GAAJ,CAAQ,CAAC,UAAD,CAAR,CAAhB;AACA,IAAA,SAAO,CAAC,OAAR,CAAgB,UAAA,KAAA,EAAK;AACnB,UAAI,eAAe,CAAC,KAAD,CAAnB,EAA4B;AAC1B,QAAA,OAAA,GACE,SAAC,CAAA,CAAA,WACD,CAAA,KAAA,CADC,EACD,8CACE,0BAAkC,CAAA,KAAA,EAAM,KAAN,CADpC,GAC0C,4BAD1C,GAEuC,KAAC,CAAO,IAAR,CACvC,KAJC,CADH,GAKE,SAAA,CAAA,CAAA,WAAA,CAAA,KAAA,CAAA,EAAA,CAAA,CALF;AAMA,QAAA,MAAM,CAAC,MAAP,CAAc,KAAd,EAAqB,OAArB,CAA6B,SAAO,CAAC,GAArC,EAA0C,SAA1C;AACD;AACF,KAVD;AAWD;AACF","sourcesContent":["import { invariant, InvariantError } from '../../utilities/globals';\n\nimport {\n  DocumentNode,\n  FieldNode,\n  SelectionSetNode,\n} from 'graphql';\nimport { wrap, OptimisticWrapperFunction } from 'optimism';\n\nimport {\n  isField,\n  resultKeyNameFromField,\n  Reference,\n  isReference,\n  makeReference,\n  StoreObject,\n  createFragmentMap,\n  FragmentMap,\n  shouldInclude,\n  addTypenameToDocument,\n  getDefaultValues,\n  getFragmentDefinitions,\n  getMainDefinition,\n  getQueryDefinition,\n  mergeDeepArray,\n  getFragmentFromSelection,\n  maybeDeepFreeze,\n  isNonNullObject,\n  canUseWeakMap,\n  compact,\n} from '../../utilities';\nimport { Cache } from '../core/types/Cache';\nimport {\n  DiffQueryAgainstStoreOptions,\n  NormalizedCache,\n  ReadMergeModifyContext,\n} from './types';\nimport { maybeDependOnExistenceOfEntity, supportsResultCaching } from './entityStore';\nimport { getTypenameFromStoreObject, shouldCanonizeResults } from './helpers';\nimport { Policies } from './policies';\nimport { InMemoryCache } from './inMemoryCache';\nimport { MissingFieldError } from '../core/types/common';\nimport { canonicalStringify, ObjectCanon } from './object-canon';\n\nexport type VariableMap = { [name: string]: any };\n\ninterface ReadContext extends ReadMergeModifyContext {\n  query: DocumentNode;\n  policies: Policies;\n  canonizeResults: boolean;\n  fragmentMap: FragmentMap;\n  path: (string | number)[];\n};\n\nexport type ExecResult<R = any> = {\n  result: R;\n  missing?: MissingFieldError[];\n};\n\nfunction missingFromInvariant(\n  err: InvariantError,\n  context: ReadContext,\n) {\n  return new MissingFieldError(\n    err.message,\n    context.path.slice(),\n    context.query,\n    context.variables,\n  );\n}\n\ntype ExecSelectionSetOptions = {\n  selectionSet: SelectionSetNode;\n  objectOrReference: StoreObject | Reference;\n  enclosingRef: Reference;\n  context: ReadContext;\n};\n\ntype ExecSubSelectedArrayOptions = {\n  field: FieldNode;\n  array: any[];\n  enclosingRef: Reference;\n  context: ReadContext;\n};\n\nexport interface StoreReaderConfig {\n  cache: InMemoryCache,\n  addTypename?: boolean;\n  resultCacheMaxSize?: number;\n  canonizeResults?: boolean;\n  canon?: ObjectCanon;\n}\n\n// Arguments type after keyArgs translation.\ntype ExecSelectionSetKeyArgs = [\n  SelectionSetNode,\n  StoreObject | Reference,\n  ReadMergeModifyContext,\n  boolean,\n];\n\nfunction execSelectionSetKeyArgs(\n  options: ExecSelectionSetOptions,\n): ExecSelectionSetKeyArgs {\n  return [\n    options.selectionSet,\n    options.objectOrReference,\n    options.context,\n    // We split out this property so we can pass different values\n    // independently without modifying options.context itself.\n    options.context.canonizeResults,\n  ];\n}\n\nexport class StoreReader {\n  // cached version of executeSelectionSet\n  private executeSelectionSet: OptimisticWrapperFunction<\n    [ExecSelectionSetOptions], // Actual arguments tuple type.\n    ExecResult, // Actual return type.\n    ExecSelectionSetKeyArgs\n  >;\n\n  // cached version of executeSubSelectedArray\n  private executeSubSelectedArray: OptimisticWrapperFunction<\n    [ExecSubSelectedArrayOptions],\n    ExecResult<any>,\n    [ExecSubSelectedArrayOptions]>;\n\n  private config: {\n    cache: InMemoryCache,\n    addTypename: boolean;\n    resultCacheMaxSize?: number;\n    canonizeResults: boolean;\n  };\n\n  private knownResults = new (\n    canUseWeakMap ? WeakMap : Map\n  )<Record<string, any>, SelectionSetNode>();\n\n  public canon: ObjectCanon;\n  public resetCanon() {\n    this.canon = new ObjectCanon;\n  }\n\n  constructor(config: StoreReaderConfig) {\n    this.config = compact(config, {\n      addTypename: config.addTypename !== false,\n      canonizeResults: shouldCanonizeResults(config),\n    });\n\n    this.canon = config.canon || new ObjectCanon;\n\n    this.executeSelectionSet = wrap(options => {\n      const { canonizeResults } = options.context;\n\n      const peekArgs = execSelectionSetKeyArgs(options);\n\n      // Negate this boolean option so we can find out if we've already read\n      // this result using the other boolean value.\n      peekArgs[3] = !canonizeResults;\n\n      const other = this.executeSelectionSet.peek(...peekArgs);\n\n      if (other) {\n        if (canonizeResults) {\n          return {\n            ...other,\n            // If we previously read this result without canonizing it, we can\n            // reuse that result simply by canonizing it now.\n            result: this.canon.admit(other.result),\n          };\n        }\n        // If we previously read this result with canonization enabled, we can\n        // return that canonized result as-is.\n        return other;\n      }\n\n      maybeDependOnExistenceOfEntity(\n        options.context.store,\n        options.enclosingRef.__ref,\n      );\n\n      // Finally, if we didn't find any useful previous results, run the real\n      // execSelectionSetImpl method with the given options.\n      return this.execSelectionSetImpl(options);\n\n    }, {\n      max: this.config.resultCacheMaxSize,\n      keyArgs: execSelectionSetKeyArgs,\n      // Note that the parameters of makeCacheKey are determined by the\n      // array returned by keyArgs.\n      makeCacheKey(selectionSet, parent, context, canonizeResults) {\n        if (supportsResultCaching(context.store)) {\n          return context.store.makeCacheKey(\n            selectionSet,\n            isReference(parent) ? parent.__ref : parent,\n            context.varString,\n            canonizeResults,\n          );\n        }\n      }\n    });\n\n    this.executeSubSelectedArray = wrap((options: ExecSubSelectedArrayOptions) => {\n      maybeDependOnExistenceOfEntity(\n        options.context.store,\n        options.enclosingRef.__ref,\n      );\n      return this.execSubSelectedArrayImpl(options);\n    }, {\n      max: this.config.resultCacheMaxSize,\n      makeCacheKey({ field, array, context }) {\n        if (supportsResultCaching(context.store)) {\n          return context.store.makeCacheKey(\n            field,\n            array,\n            context.varString,\n          );\n        }\n      }\n    });\n  }\n\n  /**\n   * Given a store and a query, return as much of the result as possible and\n   * identify if any data was missing from the store.\n   * @param  {DocumentNode} query A parsed GraphQL query document\n   * @param  {Store} store The Apollo Client store object\n   * @return {result: Object, complete: [boolean]}\n   */\n  public diffQueryAgainstStore<T>({\n    store,\n    query,\n    rootId = 'ROOT_QUERY',\n    variables,\n    returnPartialData = true,\n    canonizeResults = this.config.canonizeResults,\n  }: DiffQueryAgainstStoreOptions): Cache.DiffResult<T> {\n    const policies = this.config.cache.policies;\n\n    variables = {\n      ...getDefaultValues(getQueryDefinition(query)),\n      ...variables!,\n    };\n\n    const rootRef = makeReference(rootId);\n    const execResult = this.executeSelectionSet({\n      selectionSet: getMainDefinition(query).selectionSet,\n      objectOrReference: rootRef,\n      enclosingRef: rootRef,\n      context: {\n        store,\n        query,\n        policies,\n        variables,\n        varString: canonicalStringify(variables),\n        canonizeResults,\n        fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n        path: [],\n      },\n    });\n\n    const hasMissingFields =\n      execResult.missing && execResult.missing.length > 0;\n    if (hasMissingFields && !returnPartialData) {\n      throw execResult.missing![0];\n    }\n\n    return {\n      result: execResult.result,\n      missing: execResult.missing,\n      complete: !hasMissingFields,\n    };\n  }\n\n  public isFresh(\n    result: Record<string, any>,\n    parent: StoreObject | Reference,\n    selectionSet: SelectionSetNode,\n    context: ReadMergeModifyContext,\n  ): boolean {\n    if (supportsResultCaching(context.store) &&\n        this.knownResults.get(result) === selectionSet) {\n      const latest = this.executeSelectionSet.peek(\n        selectionSet,\n        parent,\n        context,\n        // If result is canonical, then it could only have been previously\n        // cached by the canonizing version of executeSelectionSet, so we can\n        // avoid checking both possibilities here.\n        this.canon.isKnown(result),\n      );\n      if (latest && result === latest.result) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Uncached version of executeSelectionSet.\n  private execSelectionSetImpl({\n    selectionSet,\n    objectOrReference,\n    enclosingRef,\n    context,\n  }: ExecSelectionSetOptions): ExecResult {\n    if (isReference(objectOrReference) &&\n        !context.policies.rootTypenamesById[objectOrReference.__ref] &&\n        !context.store.has(objectOrReference.__ref)) {\n      return {\n        result: this.canon.empty,\n        missing: [missingFromInvariant(\n          new InvariantError(\n            `Dangling reference to missing ${objectOrReference.__ref} object`\n          ),\n          context,\n        )],\n      };\n    }\n\n    const { variables, policies, store } = context;\n    const objectsToMerge: { [key: string]: any }[] = [];\n    const finalResult: ExecResult = { result: null };\n    const typename = store.getFieldValue<string>(objectOrReference, \"__typename\");\n\n    if (this.config.addTypename &&\n        typeof typename === \"string\" &&\n        !policies.rootIdsByTypename[typename]) {\n      // Ensure we always include a default value for the __typename\n      // field, if we have one, and this.config.addTypename is true. Note\n      // that this field can be overridden by other merged objects.\n      objectsToMerge.push({ __typename: typename });\n    }\n\n    function getMissing() {\n      return finalResult.missing || (finalResult.missing = []);\n    }\n\n    function handleMissing<T>(result: ExecResult<T>): T {\n      if (result.missing) getMissing().push(...result.missing);\n      return result.result;\n    }\n\n    const workSet = new Set(selectionSet.selections);\n\n    workSet.forEach(selection => {\n      // Omit fields with directives @skip(if: <truthy value>) or\n      // @include(if: <falsy value>).\n      if (!shouldInclude(selection, variables)) return;\n\n      if (isField(selection)) {\n        let fieldValue = policies.readField({\n          fieldName: selection.name.value,\n          field: selection,\n          variables: context.variables,\n          from: objectOrReference,\n        }, context);\n\n        const resultName = resultKeyNameFromField(selection);\n        context.path.push(resultName);\n\n        if (fieldValue === void 0) {\n          if (!addTypenameToDocument.added(selection)) {\n            getMissing().push(\n              missingFromInvariant(\n                new InvariantError(`Can't find field '${\n                  selection.name.value\n                }' on ${\n                  isReference(objectOrReference)\n                    ? objectOrReference.__ref + \" object\"\n                    : \"object \" + JSON.stringify(objectOrReference, null, 2)\n                }`),\n                context,\n              ),\n            );\n          }\n\n        } else if (Array.isArray(fieldValue)) {\n          fieldValue = handleMissing(this.executeSubSelectedArray({\n            field: selection,\n            array: fieldValue,\n            enclosingRef,\n            context,\n          }));\n\n        } else if (!selection.selectionSet) {\n          // If the field does not have a selection set, then we handle it\n          // as a scalar value. To keep this.canon from canonicalizing\n          // this value, we use this.canon.pass to wrap fieldValue in a\n          // Pass object that this.canon.admit will later unwrap as-is.\n          if (context.canonizeResults) {\n            fieldValue = this.canon.pass(fieldValue);\n          }\n\n        } else if (fieldValue != null) {\n          // In this case, because we know the field has a selection set,\n          // it must be trying to query a GraphQLObjectType, which is why\n          // fieldValue must be != null.\n          fieldValue = handleMissing(this.executeSelectionSet({\n            selectionSet: selection.selectionSet,\n            objectOrReference: fieldValue as StoreObject | Reference,\n            enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,\n            context,\n          }));\n        }\n\n        if (fieldValue !== void 0) {\n          objectsToMerge.push({ [resultName]: fieldValue });\n        }\n\n        invariant(context.path.pop() === resultName);\n\n      } else {\n        const fragment = getFragmentFromSelection(\n          selection,\n          context.fragmentMap,\n        );\n\n        if (fragment && policies.fragmentMatches(fragment, typename)) {\n          fragment.selectionSet.selections.forEach(workSet.add, workSet);\n        }\n      }\n    });\n\n    // Perform a single merge at the end so that we can avoid making more\n    // defensive shallow copies than necessary.\n    const merged = mergeDeepArray(objectsToMerge);\n    finalResult.result = context.canonizeResults\n      ? this.canon.admit(merged)\n      // Since this.canon is normally responsible for freezing results (only in\n      // development), freeze them manually if canonization is disabled.\n      : maybeDeepFreeze(merged);\n\n    // Store this result with its selection set so that we can quickly\n    // recognize it again in the StoreReader#isFresh method.\n    this.knownResults.set(finalResult.result, selectionSet);\n\n    return finalResult;\n  }\n\n  // Uncached version of executeSubSelectedArray.\n  private execSubSelectedArrayImpl({\n    field,\n    array,\n    enclosingRef,\n    context,\n  }: ExecSubSelectedArrayOptions): ExecResult {\n    let missing: MissingFieldError[] | undefined;\n\n    function handleMissing<T>(childResult: ExecResult<T>, i: number): T {\n      if (childResult.missing) {\n        missing = missing || [];\n        missing.push(...childResult.missing);\n      }\n\n      invariant(context.path.pop() === i);\n\n      return childResult.result;\n    }\n\n    if (field.selectionSet) {\n      array = array.filter(context.store.canRead);\n    }\n\n    array = array.map((item, i) => {\n      // null value in array\n      if (item === null) {\n        return null;\n      }\n\n      context.path.push(i);\n\n      // This is a nested array, recurse\n      if (Array.isArray(item)) {\n        return handleMissing(this.executeSubSelectedArray({\n          field,\n          array: item,\n          enclosingRef,\n          context,\n        }), i);\n      }\n\n      // This is an object, run the selection set on it\n      if (field.selectionSet) {\n        return handleMissing(this.executeSelectionSet({\n          selectionSet: field.selectionSet,\n          objectOrReference: item,\n          enclosingRef: isReference(item) ? item : enclosingRef,\n          context,\n        }), i);\n      }\n\n      if (__DEV__) {\n        assertSelectionSetForIdValue(context.store, field, item);\n      }\n\n      invariant(context.path.pop() === i);\n\n      return item;\n    });\n\n    return {\n      result: context.canonizeResults ? this.canon.admit(array) : array,\n      missing,\n    };\n  }\n}\n\nfunction assertSelectionSetForIdValue(\n  store: NormalizedCache,\n  field: FieldNode,\n  fieldValue: any,\n) {\n  if (!field.selectionSet) {\n    const workSet = new Set([fieldValue]);\n    workSet.forEach(value => {\n      if (isNonNullObject(value)) {\n        invariant(\n          !isReference(value),\n          `Missing selection set for object of type ${\n            getTypenameFromStoreObject(store, value)\n          } returned for query field ${field.name.value}`,\n        );\n        Object.values(value).forEach(workSet.add, workSet);\n      }\n    });\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}