{"ast":null,"code":"import { inspect } from '../jsutils/inspect.mjs';\nimport { toObjMap } from '../jsutils/toObjMap.mjs';\nimport { devAssert } from '../jsutils/devAssert.mjs';\nimport { instanceOf } from '../jsutils/instanceOf.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { __Schema } from './introspection.mjs';\nimport { isDirective, specifiedDirectives } from './directives.mjs';\nimport { isObjectType, isInterfaceType, isUnionType, isInputObjectType, getNamedType } from './definition.mjs';\n/**\n * Test if the given value is a GraphQL schema.\n */\n\nexport function isSchema(schema) {\n  return instanceOf(schema, GraphQLSchema);\n}\nexport function assertSchema(schema) {\n  if (!isSchema(schema)) {\n    throw new Error(`Expected ${inspect(schema)} to be a GraphQL schema.`);\n  }\n\n  return schema;\n}\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\n\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n * ```ts\n * const MyAppSchema = new GraphQLSchema({\n *   query: MyAppQueryRootType,\n *   mutation: MyAppMutationRootType,\n * })\n * ```\n *\n * Note: When the schema is constructed, by default only the types that are\n * reachable by traversing the root types are included, other types must be\n * explicitly referenced.\n *\n * Example:\n *\n * ```ts\n * const characterInterface = new GraphQLInterfaceType({\n *   name: 'Character',\n *   ...\n * });\n *\n * const humanType = new GraphQLObjectType({\n *   name: 'Human',\n *   interfaces: [characterInterface],\n *   ...\n * });\n *\n * const droidType = new GraphQLObjectType({\n *   name: 'Droid',\n *   interfaces: [characterInterface],\n *   ...\n * });\n *\n * const schema = new GraphQLSchema({\n *   query: new GraphQLObjectType({\n *     name: 'Query',\n *     fields: {\n *       hero: { type: characterInterface, ... },\n *     }\n *   }),\n *   ...\n *   // Since this schema references only the `Character` interface it's\n *   // necessary to explicitly list the types that implement it if\n *   // you want them to be included in the final schema.\n *   types: [humanType, droidType],\n * })\n * ```\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. `@include` and\n * `@skip`) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n * ```ts\n * const MyAppSchema = new GraphQLSchema({\n *   ...\n *   directives: specifiedDirectives.concat([ myCustomDirective ]),\n * })\n * ```\n */\n\nexport class GraphQLSchema {\n  // Used as a cache for validateSchema().\n  constructor(config) {\n    var _config$extensionASTN, _config$directives; // If this schema was built from a source known to be valid, then it may be\n    // marked with assumeValid to avoid an additional type system validation.\n\n\n    this.__validationErrors = config.assumeValid === true ? [] : undefined; // Check for common mistakes during construction to produce early errors.\n\n    isObjectLike(config) || devAssert(false, 'Must provide configuration object.');\n    !config.types || Array.isArray(config.types) || devAssert(false, `\"types\" must be Array if provided but got: ${inspect(config.types)}.`);\n    !config.directives || Array.isArray(config.directives) || devAssert(false, '\"directives\" must be Array if provided but got: ' + `${inspect(config.directives)}.`);\n    this.description = config.description;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];\n    this._queryType = config.query;\n    this._mutationType = config.mutation;\n    this._subscriptionType = config.subscription; // Provide specified directives (e.g. @include and @skip) by default.\n\n    this._directives = (_config$directives = config.directives) !== null && _config$directives !== void 0 ? _config$directives : specifiedDirectives; // To preserve order of user-provided types, we add first to add them to\n    // the set of \"collected\" types, so `collectReferencedTypes` ignore them.\n\n    const allReferencedTypes = new Set(config.types);\n\n    if (config.types != null) {\n      for (const type of config.types) {\n        // When we ready to process this type, we remove it from \"collected\" types\n        // and then add it together with all dependent types in the correct position.\n        allReferencedTypes.delete(type);\n        collectReferencedTypes(type, allReferencedTypes);\n      }\n    }\n\n    if (this._queryType != null) {\n      collectReferencedTypes(this._queryType, allReferencedTypes);\n    }\n\n    if (this._mutationType != null) {\n      collectReferencedTypes(this._mutationType, allReferencedTypes);\n    }\n\n    if (this._subscriptionType != null) {\n      collectReferencedTypes(this._subscriptionType, allReferencedTypes);\n    }\n\n    for (const directive of this._directives) {\n      // Directives are not validated until validateSchema() is called.\n      if (isDirective(directive)) {\n        for (const arg of directive.args) {\n          collectReferencedTypes(arg.type, allReferencedTypes);\n        }\n      }\n    }\n\n    collectReferencedTypes(__Schema, allReferencedTypes); // Storing the resulting map for reference by the schema.\n\n    this._typeMap = Object.create(null);\n    this._subTypeMap = Object.create(null); // Keep track of all implementations by interface name.\n\n    this._implementationsMap = Object.create(null);\n\n    for (const namedType of allReferencedTypes) {\n      if (namedType == null) {\n        continue;\n      }\n\n      const typeName = namedType.name;\n      typeName || devAssert(false, 'One of the provided types for building the Schema is missing a name.');\n\n      if (this._typeMap[typeName] !== undefined) {\n        throw new Error(`Schema must contain uniquely named types but contains multiple types named \"${typeName}\".`);\n      }\n\n      this._typeMap[typeName] = namedType;\n\n      if (isInterfaceType(namedType)) {\n        // Store implementations by interface.\n        for (const iface of namedType.getInterfaces()) {\n          if (isInterfaceType(iface)) {\n            let implementations = this._implementationsMap[iface.name];\n\n            if (implementations === undefined) {\n              implementations = this._implementationsMap[iface.name] = {\n                objects: [],\n                interfaces: []\n              };\n            }\n\n            implementations.interfaces.push(namedType);\n          }\n        }\n      } else if (isObjectType(namedType)) {\n        // Store implementations by objects.\n        for (const iface of namedType.getInterfaces()) {\n          if (isInterfaceType(iface)) {\n            let implementations = this._implementationsMap[iface.name];\n\n            if (implementations === undefined) {\n              implementations = this._implementationsMap[iface.name] = {\n                objects: [],\n                interfaces: []\n              };\n            }\n\n            implementations.objects.push(namedType);\n          }\n        }\n      }\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLSchema';\n  }\n\n  getQueryType() {\n    return this._queryType;\n  }\n\n  getMutationType() {\n    return this._mutationType;\n  }\n\n  getSubscriptionType() {\n    return this._subscriptionType;\n  }\n\n  getRootType(operation) {\n    switch (operation) {\n      case 'query':\n        return this.getQueryType();\n\n      case 'mutation':\n        return this.getMutationType();\n\n      case 'subscription':\n        return this.getSubscriptionType();\n    }\n  }\n\n  getTypeMap() {\n    return this._typeMap;\n  }\n\n  getType(name) {\n    return this.getTypeMap()[name];\n  }\n\n  getPossibleTypes(abstractType) {\n    return isUnionType(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;\n  }\n\n  getImplementations(interfaceType) {\n    const implementations = this._implementationsMap[interfaceType.name];\n    return implementations !== null && implementations !== void 0 ? implementations : {\n      objects: [],\n      interfaces: []\n    };\n  }\n\n  isSubType(abstractType, maybeSubType) {\n    let map = this._subTypeMap[abstractType.name];\n\n    if (map === undefined) {\n      map = Object.create(null);\n\n      if (isUnionType(abstractType)) {\n        for (const type of abstractType.getTypes()) {\n          map[type.name] = true;\n        }\n      } else {\n        const implementations = this.getImplementations(abstractType);\n\n        for (const type of implementations.objects) {\n          map[type.name] = true;\n        }\n\n        for (const type of implementations.interfaces) {\n          map[type.name] = true;\n        }\n      }\n\n      this._subTypeMap[abstractType.name] = map;\n    }\n\n    return map[maybeSubType.name] !== undefined;\n  }\n\n  getDirectives() {\n    return this._directives;\n  }\n\n  getDirective(name) {\n    return this.getDirectives().find(directive => directive.name === name);\n  }\n\n  toConfig() {\n    return {\n      description: this.description,\n      query: this.getQueryType(),\n      mutation: this.getMutationType(),\n      subscription: this.getSubscriptionType(),\n      types: Object.values(this.getTypeMap()),\n      directives: this.getDirectives(),\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n      assumeValid: this.__validationErrors !== undefined\n    };\n  }\n\n}\n\nfunction collectReferencedTypes(type, typeSet) {\n  const namedType = getNamedType(type);\n\n  if (!typeSet.has(namedType)) {\n    typeSet.add(namedType);\n\n    if (isUnionType(namedType)) {\n      for (const memberType of namedType.getTypes()) {\n        collectReferencedTypes(memberType, typeSet);\n      }\n    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {\n      for (const interfaceType of namedType.getInterfaces()) {\n        collectReferencedTypes(interfaceType, typeSet);\n      }\n\n      for (const field of Object.values(namedType.getFields())) {\n        collectReferencedTypes(field.type, typeSet);\n\n        for (const arg of field.args) {\n          collectReferencedTypes(arg.type, typeSet);\n        }\n      }\n    } else if (isInputObjectType(namedType)) {\n      for (const field of Object.values(namedType.getFields())) {\n        collectReferencedTypes(field.type, typeSet);\n      }\n    }\n  }\n\n  return typeSet;\n}","map":{"version":3,"sources":["/Users/adammartiska/Projects/eMenu/GUI/eMenu-customer/node_modules/graphql/type/schema.mjs"],"names":["inspect","toObjMap","devAssert","instanceOf","isObjectLike","__Schema","isDirective","specifiedDirectives","isObjectType","isInterfaceType","isUnionType","isInputObjectType","getNamedType","isSchema","schema","GraphQLSchema","assertSchema","Error","constructor","config","_config$extensionASTN","_config$directives","__validationErrors","assumeValid","undefined","types","Array","isArray","directives","description","extensions","astNode","extensionASTNodes","_queryType","query","_mutationType","mutation","_subscriptionType","subscription","_directives","allReferencedTypes","Set","type","delete","collectReferencedTypes","directive","arg","args","_typeMap","Object","create","_subTypeMap","_implementationsMap","namedType","typeName","name","iface","getInterfaces","implementations","objects","interfaces","push","Symbol","toStringTag","getQueryType","getMutationType","getSubscriptionType","getRootType","operation","getTypeMap","getType","getPossibleTypes","abstractType","getTypes","getImplementations","interfaceType","isSubType","maybeSubType","map","getDirectives","getDirective","find","toConfig","values","typeSet","has","add","memberType","field","getFields"],"mappings":"AAAA,SAASA,OAAT,QAAwB,wBAAxB;AACA,SAASC,QAAT,QAAyB,yBAAzB;AACA,SAASC,SAAT,QAA0B,0BAA1B;AACA,SAASC,UAAT,QAA2B,2BAA3B;AACA,SAASC,YAAT,QAA6B,6BAA7B;AACA,SAASC,QAAT,QAAyB,qBAAzB;AACA,SAASC,WAAT,EAAsBC,mBAAtB,QAAiD,kBAAjD;AACA,SACEC,YADF,EAEEC,eAFF,EAGEC,WAHF,EAIEC,iBAJF,EAKEC,YALF,QAMO,kBANP;AAOA;AACA;AACA;;AAEA,OAAO,SAASC,QAAT,CAAkBC,MAAlB,EAA0B;AAC/B,SAAOX,UAAU,CAACW,MAAD,EAASC,aAAT,CAAjB;AACD;AACD,OAAO,SAASC,YAAT,CAAsBF,MAAtB,EAA8B;AACnC,MAAI,CAACD,QAAQ,CAACC,MAAD,CAAb,EAAuB;AACrB,UAAM,IAAIG,KAAJ,CAAW,YAAWjB,OAAO,CAACc,MAAD,CAAS,0BAAtC,CAAN;AACD;;AAED,SAAOA,MAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,aAAN,CAAoB;AACzB;AACAG,EAAAA,WAAW,CAACC,MAAD,EAAS;AAClB,QAAIC,qBAAJ,EAA2BC,kBAA3B,CADkB,CAGlB;AACA;;;AACA,SAAKC,kBAAL,GAA0BH,MAAM,CAACI,WAAP,KAAuB,IAAvB,GAA8B,EAA9B,GAAmCC,SAA7D,CALkB,CAKsD;;AAExEpB,IAAAA,YAAY,CAACe,MAAD,CAAZ,IACEjB,SAAS,CAAC,KAAD,EAAQ,oCAAR,CADX;AAEA,KAACiB,MAAM,CAACM,KAAR,IACEC,KAAK,CAACC,OAAN,CAAcR,MAAM,CAACM,KAArB,CADF,IAEEvB,SAAS,CACP,KADO,EAEN,8CAA6CF,OAAO,CAACmB,MAAM,CAACM,KAAR,CAAe,GAF7D,CAFX;AAMA,KAACN,MAAM,CAACS,UAAR,IACEF,KAAK,CAACC,OAAN,CAAcR,MAAM,CAACS,UAArB,CADF,IAEE1B,SAAS,CACP,KADO,EAEP,qDACG,GAAEF,OAAO,CAACmB,MAAM,CAACS,UAAR,CAAoB,GAHzB,CAFX;AAOA,SAAKC,WAAL,GAAmBV,MAAM,CAACU,WAA1B;AACA,SAAKC,UAAL,GAAkB7B,QAAQ,CAACkB,MAAM,CAACW,UAAR,CAA1B;AACA,SAAKC,OAAL,GAAeZ,MAAM,CAACY,OAAtB;AACA,SAAKC,iBAAL,GACE,CAACZ,qBAAqB,GAAGD,MAAM,CAACa,iBAAhC,MAAuD,IAAvD,IACAZ,qBAAqB,KAAK,KAAK,CAD/B,GAEIA,qBAFJ,GAGI,EAJN;AAKA,SAAKa,UAAL,GAAkBd,MAAM,CAACe,KAAzB;AACA,SAAKC,aAAL,GAAqBhB,MAAM,CAACiB,QAA5B;AACA,SAAKC,iBAAL,GAAyBlB,MAAM,CAACmB,YAAhC,CAhCkB,CAgC4B;;AAE9C,SAAKC,WAAL,GACE,CAAClB,kBAAkB,GAAGF,MAAM,CAACS,UAA7B,MAA6C,IAA7C,IACAP,kBAAkB,KAAK,KAAK,CAD5B,GAEIA,kBAFJ,GAGId,mBAJN,CAlCkB,CAsCS;AAC3B;;AAEA,UAAMiC,kBAAkB,GAAG,IAAIC,GAAJ,CAAQtB,MAAM,CAACM,KAAf,CAA3B;;AAEA,QAAIN,MAAM,CAACM,KAAP,IAAgB,IAApB,EAA0B;AACxB,WAAK,MAAMiB,IAAX,IAAmBvB,MAAM,CAACM,KAA1B,EAAiC;AAC/B;AACA;AACAe,QAAAA,kBAAkB,CAACG,MAAnB,CAA0BD,IAA1B;AACAE,QAAAA,sBAAsB,CAACF,IAAD,EAAOF,kBAAP,CAAtB;AACD;AACF;;AAED,QAAI,KAAKP,UAAL,IAAmB,IAAvB,EAA6B;AAC3BW,MAAAA,sBAAsB,CAAC,KAAKX,UAAN,EAAkBO,kBAAlB,CAAtB;AACD;;AAED,QAAI,KAAKL,aAAL,IAAsB,IAA1B,EAAgC;AAC9BS,MAAAA,sBAAsB,CAAC,KAAKT,aAAN,EAAqBK,kBAArB,CAAtB;AACD;;AAED,QAAI,KAAKH,iBAAL,IAA0B,IAA9B,EAAoC;AAClCO,MAAAA,sBAAsB,CAAC,KAAKP,iBAAN,EAAyBG,kBAAzB,CAAtB;AACD;;AAED,SAAK,MAAMK,SAAX,IAAwB,KAAKN,WAA7B,EAA0C;AACxC;AACA,UAAIjC,WAAW,CAACuC,SAAD,CAAf,EAA4B;AAC1B,aAAK,MAAMC,GAAX,IAAkBD,SAAS,CAACE,IAA5B,EAAkC;AAChCH,UAAAA,sBAAsB,CAACE,GAAG,CAACJ,IAAL,EAAWF,kBAAX,CAAtB;AACD;AACF;AACF;;AAEDI,IAAAA,sBAAsB,CAACvC,QAAD,EAAWmC,kBAAX,CAAtB,CAzEkB,CAyEoC;;AAEtD,SAAKQ,QAAL,GAAgBC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAhB;AACA,SAAKC,WAAL,GAAmBF,MAAM,CAACC,MAAP,CAAc,IAAd,CAAnB,CA5EkB,CA4EsB;;AAExC,SAAKE,mBAAL,GAA2BH,MAAM,CAACC,MAAP,CAAc,IAAd,CAA3B;;AAEA,SAAK,MAAMG,SAAX,IAAwBb,kBAAxB,EAA4C;AAC1C,UAAIa,SAAS,IAAI,IAAjB,EAAuB;AACrB;AACD;;AAED,YAAMC,QAAQ,GAAGD,SAAS,CAACE,IAA3B;AACAD,MAAAA,QAAQ,IACNpD,SAAS,CACP,KADO,EAEP,sEAFO,CADX;;AAMA,UAAI,KAAK8C,QAAL,CAAcM,QAAd,MAA4B9B,SAAhC,EAA2C;AACzC,cAAM,IAAIP,KAAJ,CACH,+EAA8EqC,QAAS,IADpF,CAAN;AAGD;;AAED,WAAKN,QAAL,CAAcM,QAAd,IAA0BD,SAA1B;;AAEA,UAAI5C,eAAe,CAAC4C,SAAD,CAAnB,EAAgC;AAC9B;AACA,aAAK,MAAMG,KAAX,IAAoBH,SAAS,CAACI,aAAV,EAApB,EAA+C;AAC7C,cAAIhD,eAAe,CAAC+C,KAAD,CAAnB,EAA4B;AAC1B,gBAAIE,eAAe,GAAG,KAAKN,mBAAL,CAAyBI,KAAK,CAACD,IAA/B,CAAtB;;AAEA,gBAAIG,eAAe,KAAKlC,SAAxB,EAAmC;AACjCkC,cAAAA,eAAe,GAAG,KAAKN,mBAAL,CAAyBI,KAAK,CAACD,IAA/B,IAAuC;AACvDI,gBAAAA,OAAO,EAAE,EAD8C;AAEvDC,gBAAAA,UAAU,EAAE;AAF2C,eAAzD;AAID;;AAEDF,YAAAA,eAAe,CAACE,UAAhB,CAA2BC,IAA3B,CAAgCR,SAAhC;AACD;AACF;AACF,OAhBD,MAgBO,IAAI7C,YAAY,CAAC6C,SAAD,CAAhB,EAA6B;AAClC;AACA,aAAK,MAAMG,KAAX,IAAoBH,SAAS,CAACI,aAAV,EAApB,EAA+C;AAC7C,cAAIhD,eAAe,CAAC+C,KAAD,CAAnB,EAA4B;AAC1B,gBAAIE,eAAe,GAAG,KAAKN,mBAAL,CAAyBI,KAAK,CAACD,IAA/B,CAAtB;;AAEA,gBAAIG,eAAe,KAAKlC,SAAxB,EAAmC;AACjCkC,cAAAA,eAAe,GAAG,KAAKN,mBAAL,CAAyBI,KAAK,CAACD,IAA/B,IAAuC;AACvDI,gBAAAA,OAAO,EAAE,EAD8C;AAEvDC,gBAAAA,UAAU,EAAE;AAF2C,eAAzD;AAID;;AAEDF,YAAAA,eAAe,CAACC,OAAhB,CAAwBE,IAAxB,CAA6BR,SAA7B;AACD;AACF;AACF;AACF;AACF;;AAEsB,OAAlBS,MAAM,CAACC,WAAW,IAAI;AACzB,WAAO,eAAP;AACD;;AAEDC,EAAAA,YAAY,GAAG;AACb,WAAO,KAAK/B,UAAZ;AACD;;AAEDgC,EAAAA,eAAe,GAAG;AAChB,WAAO,KAAK9B,aAAZ;AACD;;AAED+B,EAAAA,mBAAmB,GAAG;AACpB,WAAO,KAAK7B,iBAAZ;AACD;;AAED8B,EAAAA,WAAW,CAACC,SAAD,EAAY;AACrB,YAAQA,SAAR;AACE,WAAK,OAAL;AACE,eAAO,KAAKJ,YAAL,EAAP;;AAEF,WAAK,UAAL;AACE,eAAO,KAAKC,eAAL,EAAP;;AAEF,WAAK,cAAL;AACE,eAAO,KAAKC,mBAAL,EAAP;AARJ;AAUD;;AAEDG,EAAAA,UAAU,GAAG;AACX,WAAO,KAAKrB,QAAZ;AACD;;AAEDsB,EAAAA,OAAO,CAACf,IAAD,EAAO;AACZ,WAAO,KAAKc,UAAL,GAAkBd,IAAlB,CAAP;AACD;;AAEDgB,EAAAA,gBAAgB,CAACC,YAAD,EAAe;AAC7B,WAAO9D,WAAW,CAAC8D,YAAD,CAAX,GACHA,YAAY,CAACC,QAAb,EADG,GAEH,KAAKC,kBAAL,CAAwBF,YAAxB,EAAsCb,OAF1C;AAGD;;AAEDe,EAAAA,kBAAkB,CAACC,aAAD,EAAgB;AAChC,UAAMjB,eAAe,GAAG,KAAKN,mBAAL,CAAyBuB,aAAa,CAACpB,IAAvC,CAAxB;AACA,WAAOG,eAAe,KAAK,IAApB,IAA4BA,eAAe,KAAK,KAAK,CAArD,GACHA,eADG,GAEH;AACEC,MAAAA,OAAO,EAAE,EADX;AAEEC,MAAAA,UAAU,EAAE;AAFd,KAFJ;AAMD;;AAEDgB,EAAAA,SAAS,CAACJ,YAAD,EAAeK,YAAf,EAA6B;AACpC,QAAIC,GAAG,GAAG,KAAK3B,WAAL,CAAiBqB,YAAY,CAACjB,IAA9B,CAAV;;AAEA,QAAIuB,GAAG,KAAKtD,SAAZ,EAAuB;AACrBsD,MAAAA,GAAG,GAAG7B,MAAM,CAACC,MAAP,CAAc,IAAd,CAAN;;AAEA,UAAIxC,WAAW,CAAC8D,YAAD,CAAf,EAA+B;AAC7B,aAAK,MAAM9B,IAAX,IAAmB8B,YAAY,CAACC,QAAb,EAAnB,EAA4C;AAC1CK,UAAAA,GAAG,CAACpC,IAAI,CAACa,IAAN,CAAH,GAAiB,IAAjB;AACD;AACF,OAJD,MAIO;AACL,cAAMG,eAAe,GAAG,KAAKgB,kBAAL,CAAwBF,YAAxB,CAAxB;;AAEA,aAAK,MAAM9B,IAAX,IAAmBgB,eAAe,CAACC,OAAnC,EAA4C;AAC1CmB,UAAAA,GAAG,CAACpC,IAAI,CAACa,IAAN,CAAH,GAAiB,IAAjB;AACD;;AAED,aAAK,MAAMb,IAAX,IAAmBgB,eAAe,CAACE,UAAnC,EAA+C;AAC7CkB,UAAAA,GAAG,CAACpC,IAAI,CAACa,IAAN,CAAH,GAAiB,IAAjB;AACD;AACF;;AAED,WAAKJ,WAAL,CAAiBqB,YAAY,CAACjB,IAA9B,IAAsCuB,GAAtC;AACD;;AAED,WAAOA,GAAG,CAACD,YAAY,CAACtB,IAAd,CAAH,KAA2B/B,SAAlC;AACD;;AAEDuD,EAAAA,aAAa,GAAG;AACd,WAAO,KAAKxC,WAAZ;AACD;;AAEDyC,EAAAA,YAAY,CAACzB,IAAD,EAAO;AACjB,WAAO,KAAKwB,aAAL,GAAqBE,IAArB,CAA2BpC,SAAD,IAAeA,SAAS,CAACU,IAAV,KAAmBA,IAA5D,CAAP;AACD;;AAED2B,EAAAA,QAAQ,GAAG;AACT,WAAO;AACLrD,MAAAA,WAAW,EAAE,KAAKA,WADb;AAELK,MAAAA,KAAK,EAAE,KAAK8B,YAAL,EAFF;AAGL5B,MAAAA,QAAQ,EAAE,KAAK6B,eAAL,EAHL;AAIL3B,MAAAA,YAAY,EAAE,KAAK4B,mBAAL,EAJT;AAKLzC,MAAAA,KAAK,EAAEwB,MAAM,CAACkC,MAAP,CAAc,KAAKd,UAAL,EAAd,CALF;AAMLzC,MAAAA,UAAU,EAAE,KAAKmD,aAAL,EANP;AAOLjD,MAAAA,UAAU,EAAE,KAAKA,UAPZ;AAQLC,MAAAA,OAAO,EAAE,KAAKA,OART;AASLC,MAAAA,iBAAiB,EAAE,KAAKA,iBATnB;AAULT,MAAAA,WAAW,EAAE,KAAKD,kBAAL,KAA4BE;AAVpC,KAAP;AAYD;;AAhPwB;;AAmP3B,SAASoB,sBAAT,CAAgCF,IAAhC,EAAsC0C,OAAtC,EAA+C;AAC7C,QAAM/B,SAAS,GAAGzC,YAAY,CAAC8B,IAAD,CAA9B;;AAEA,MAAI,CAAC0C,OAAO,CAACC,GAAR,CAAYhC,SAAZ,CAAL,EAA6B;AAC3B+B,IAAAA,OAAO,CAACE,GAAR,CAAYjC,SAAZ;;AAEA,QAAI3C,WAAW,CAAC2C,SAAD,CAAf,EAA4B;AAC1B,WAAK,MAAMkC,UAAX,IAAyBlC,SAAS,CAACoB,QAAV,EAAzB,EAA+C;AAC7C7B,QAAAA,sBAAsB,CAAC2C,UAAD,EAAaH,OAAb,CAAtB;AACD;AACF,KAJD,MAIO,IAAI5E,YAAY,CAAC6C,SAAD,CAAZ,IAA2B5C,eAAe,CAAC4C,SAAD,CAA9C,EAA2D;AAChE,WAAK,MAAMsB,aAAX,IAA4BtB,SAAS,CAACI,aAAV,EAA5B,EAAuD;AACrDb,QAAAA,sBAAsB,CAAC+B,aAAD,EAAgBS,OAAhB,CAAtB;AACD;;AAED,WAAK,MAAMI,KAAX,IAAoBvC,MAAM,CAACkC,MAAP,CAAc9B,SAAS,CAACoC,SAAV,EAAd,CAApB,EAA0D;AACxD7C,QAAAA,sBAAsB,CAAC4C,KAAK,CAAC9C,IAAP,EAAa0C,OAAb,CAAtB;;AAEA,aAAK,MAAMtC,GAAX,IAAkB0C,KAAK,CAACzC,IAAxB,EAA8B;AAC5BH,UAAAA,sBAAsB,CAACE,GAAG,CAACJ,IAAL,EAAW0C,OAAX,CAAtB;AACD;AACF;AACF,KAZM,MAYA,IAAIzE,iBAAiB,CAAC0C,SAAD,CAArB,EAAkC;AACvC,WAAK,MAAMmC,KAAX,IAAoBvC,MAAM,CAACkC,MAAP,CAAc9B,SAAS,CAACoC,SAAV,EAAd,CAApB,EAA0D;AACxD7C,QAAAA,sBAAsB,CAAC4C,KAAK,CAAC9C,IAAP,EAAa0C,OAAb,CAAtB;AACD;AACF;AACF;;AAED,SAAOA,OAAP;AACD","sourcesContent":["import { inspect } from '../jsutils/inspect.mjs';\nimport { toObjMap } from '../jsutils/toObjMap.mjs';\nimport { devAssert } from '../jsutils/devAssert.mjs';\nimport { instanceOf } from '../jsutils/instanceOf.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { __Schema } from './introspection.mjs';\nimport { isDirective, specifiedDirectives } from './directives.mjs';\nimport {\n  isObjectType,\n  isInterfaceType,\n  isUnionType,\n  isInputObjectType,\n  getNamedType,\n} from './definition.mjs';\n/**\n * Test if the given value is a GraphQL schema.\n */\n\nexport function isSchema(schema) {\n  return instanceOf(schema, GraphQLSchema);\n}\nexport function assertSchema(schema) {\n  if (!isSchema(schema)) {\n    throw new Error(`Expected ${inspect(schema)} to be a GraphQL schema.`);\n  }\n\n  return schema;\n}\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\n\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n * ```ts\n * const MyAppSchema = new GraphQLSchema({\n *   query: MyAppQueryRootType,\n *   mutation: MyAppMutationRootType,\n * })\n * ```\n *\n * Note: When the schema is constructed, by default only the types that are\n * reachable by traversing the root types are included, other types must be\n * explicitly referenced.\n *\n * Example:\n *\n * ```ts\n * const characterInterface = new GraphQLInterfaceType({\n *   name: 'Character',\n *   ...\n * });\n *\n * const humanType = new GraphQLObjectType({\n *   name: 'Human',\n *   interfaces: [characterInterface],\n *   ...\n * });\n *\n * const droidType = new GraphQLObjectType({\n *   name: 'Droid',\n *   interfaces: [characterInterface],\n *   ...\n * });\n *\n * const schema = new GraphQLSchema({\n *   query: new GraphQLObjectType({\n *     name: 'Query',\n *     fields: {\n *       hero: { type: characterInterface, ... },\n *     }\n *   }),\n *   ...\n *   // Since this schema references only the `Character` interface it's\n *   // necessary to explicitly list the types that implement it if\n *   // you want them to be included in the final schema.\n *   types: [humanType, droidType],\n * })\n * ```\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. `@include` and\n * `@skip`) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n * ```ts\n * const MyAppSchema = new GraphQLSchema({\n *   ...\n *   directives: specifiedDirectives.concat([ myCustomDirective ]),\n * })\n * ```\n */\nexport class GraphQLSchema {\n  // Used as a cache for validateSchema().\n  constructor(config) {\n    var _config$extensionASTN, _config$directives;\n\n    // If this schema was built from a source known to be valid, then it may be\n    // marked with assumeValid to avoid an additional type system validation.\n    this.__validationErrors = config.assumeValid === true ? [] : undefined; // Check for common mistakes during construction to produce early errors.\n\n    isObjectLike(config) ||\n      devAssert(false, 'Must provide configuration object.');\n    !config.types ||\n      Array.isArray(config.types) ||\n      devAssert(\n        false,\n        `\"types\" must be Array if provided but got: ${inspect(config.types)}.`,\n      );\n    !config.directives ||\n      Array.isArray(config.directives) ||\n      devAssert(\n        false,\n        '\"directives\" must be Array if provided but got: ' +\n          `${inspect(config.directives)}.`,\n      );\n    this.description = config.description;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes =\n      (_config$extensionASTN = config.extensionASTNodes) !== null &&\n      _config$extensionASTN !== void 0\n        ? _config$extensionASTN\n        : [];\n    this._queryType = config.query;\n    this._mutationType = config.mutation;\n    this._subscriptionType = config.subscription; // Provide specified directives (e.g. @include and @skip) by default.\n\n    this._directives =\n      (_config$directives = config.directives) !== null &&\n      _config$directives !== void 0\n        ? _config$directives\n        : specifiedDirectives; // To preserve order of user-provided types, we add first to add them to\n    // the set of \"collected\" types, so `collectReferencedTypes` ignore them.\n\n    const allReferencedTypes = new Set(config.types);\n\n    if (config.types != null) {\n      for (const type of config.types) {\n        // When we ready to process this type, we remove it from \"collected\" types\n        // and then add it together with all dependent types in the correct position.\n        allReferencedTypes.delete(type);\n        collectReferencedTypes(type, allReferencedTypes);\n      }\n    }\n\n    if (this._queryType != null) {\n      collectReferencedTypes(this._queryType, allReferencedTypes);\n    }\n\n    if (this._mutationType != null) {\n      collectReferencedTypes(this._mutationType, allReferencedTypes);\n    }\n\n    if (this._subscriptionType != null) {\n      collectReferencedTypes(this._subscriptionType, allReferencedTypes);\n    }\n\n    for (const directive of this._directives) {\n      // Directives are not validated until validateSchema() is called.\n      if (isDirective(directive)) {\n        for (const arg of directive.args) {\n          collectReferencedTypes(arg.type, allReferencedTypes);\n        }\n      }\n    }\n\n    collectReferencedTypes(__Schema, allReferencedTypes); // Storing the resulting map for reference by the schema.\n\n    this._typeMap = Object.create(null);\n    this._subTypeMap = Object.create(null); // Keep track of all implementations by interface name.\n\n    this._implementationsMap = Object.create(null);\n\n    for (const namedType of allReferencedTypes) {\n      if (namedType == null) {\n        continue;\n      }\n\n      const typeName = namedType.name;\n      typeName ||\n        devAssert(\n          false,\n          'One of the provided types for building the Schema is missing a name.',\n        );\n\n      if (this._typeMap[typeName] !== undefined) {\n        throw new Error(\n          `Schema must contain uniquely named types but contains multiple types named \"${typeName}\".`,\n        );\n      }\n\n      this._typeMap[typeName] = namedType;\n\n      if (isInterfaceType(namedType)) {\n        // Store implementations by interface.\n        for (const iface of namedType.getInterfaces()) {\n          if (isInterfaceType(iface)) {\n            let implementations = this._implementationsMap[iface.name];\n\n            if (implementations === undefined) {\n              implementations = this._implementationsMap[iface.name] = {\n                objects: [],\n                interfaces: [],\n              };\n            }\n\n            implementations.interfaces.push(namedType);\n          }\n        }\n      } else if (isObjectType(namedType)) {\n        // Store implementations by objects.\n        for (const iface of namedType.getInterfaces()) {\n          if (isInterfaceType(iface)) {\n            let implementations = this._implementationsMap[iface.name];\n\n            if (implementations === undefined) {\n              implementations = this._implementationsMap[iface.name] = {\n                objects: [],\n                interfaces: [],\n              };\n            }\n\n            implementations.objects.push(namedType);\n          }\n        }\n      }\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLSchema';\n  }\n\n  getQueryType() {\n    return this._queryType;\n  }\n\n  getMutationType() {\n    return this._mutationType;\n  }\n\n  getSubscriptionType() {\n    return this._subscriptionType;\n  }\n\n  getRootType(operation) {\n    switch (operation) {\n      case 'query':\n        return this.getQueryType();\n\n      case 'mutation':\n        return this.getMutationType();\n\n      case 'subscription':\n        return this.getSubscriptionType();\n    }\n  }\n\n  getTypeMap() {\n    return this._typeMap;\n  }\n\n  getType(name) {\n    return this.getTypeMap()[name];\n  }\n\n  getPossibleTypes(abstractType) {\n    return isUnionType(abstractType)\n      ? abstractType.getTypes()\n      : this.getImplementations(abstractType).objects;\n  }\n\n  getImplementations(interfaceType) {\n    const implementations = this._implementationsMap[interfaceType.name];\n    return implementations !== null && implementations !== void 0\n      ? implementations\n      : {\n          objects: [],\n          interfaces: [],\n        };\n  }\n\n  isSubType(abstractType, maybeSubType) {\n    let map = this._subTypeMap[abstractType.name];\n\n    if (map === undefined) {\n      map = Object.create(null);\n\n      if (isUnionType(abstractType)) {\n        for (const type of abstractType.getTypes()) {\n          map[type.name] = true;\n        }\n      } else {\n        const implementations = this.getImplementations(abstractType);\n\n        for (const type of implementations.objects) {\n          map[type.name] = true;\n        }\n\n        for (const type of implementations.interfaces) {\n          map[type.name] = true;\n        }\n      }\n\n      this._subTypeMap[abstractType.name] = map;\n    }\n\n    return map[maybeSubType.name] !== undefined;\n  }\n\n  getDirectives() {\n    return this._directives;\n  }\n\n  getDirective(name) {\n    return this.getDirectives().find((directive) => directive.name === name);\n  }\n\n  toConfig() {\n    return {\n      description: this.description,\n      query: this.getQueryType(),\n      mutation: this.getMutationType(),\n      subscription: this.getSubscriptionType(),\n      types: Object.values(this.getTypeMap()),\n      directives: this.getDirectives(),\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n      assumeValid: this.__validationErrors !== undefined,\n    };\n  }\n}\n\nfunction collectReferencedTypes(type, typeSet) {\n  const namedType = getNamedType(type);\n\n  if (!typeSet.has(namedType)) {\n    typeSet.add(namedType);\n\n    if (isUnionType(namedType)) {\n      for (const memberType of namedType.getTypes()) {\n        collectReferencedTypes(memberType, typeSet);\n      }\n    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {\n      for (const interfaceType of namedType.getInterfaces()) {\n        collectReferencedTypes(interfaceType, typeSet);\n      }\n\n      for (const field of Object.values(namedType.getFields())) {\n        collectReferencedTypes(field.type, typeSet);\n\n        for (const arg of field.args) {\n          collectReferencedTypes(arg.type, typeSet);\n        }\n      }\n    } else if (isInputObjectType(namedType)) {\n      for (const field of Object.values(namedType.getFields())) {\n        collectReferencedTypes(field.type, typeSet);\n      }\n    }\n  }\n\n  return typeSet;\n}\n"]},"metadata":{},"sourceType":"module"}