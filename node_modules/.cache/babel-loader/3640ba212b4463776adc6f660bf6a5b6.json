{"ast":null,"code":"import { isWhiteSpace } from './characterClasses.mjs';\n/**\n * Produces the value of a block string from its parsed raw value, similar to\n * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.\n *\n * This implements the GraphQL spec's BlockStringValue() static algorithm.\n *\n * @internal\n */\n\nexport function dedentBlockStringLines(lines) {\n  var _firstNonEmptyLine2;\n\n  let commonIndent = Number.MAX_SAFE_INTEGER;\n  let firstNonEmptyLine = null;\n  let lastNonEmptyLine = -1;\n\n  for (let i = 0; i < lines.length; ++i) {\n    var _firstNonEmptyLine;\n\n    const line = lines[i];\n    const indent = leadingWhitespace(line);\n\n    if (indent === line.length) {\n      continue; // skip empty lines\n    }\n\n    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;\n    lastNonEmptyLine = i;\n\n    if (i !== 0 && indent < commonIndent) {\n      commonIndent = indent;\n    }\n  }\n\n  return lines // Remove common indentation from all lines but first.\n  .map((line, i) => i === 0 ? line : line.slice(commonIndent)) // Remove leading and trailing blank lines.\n  .slice((_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0, lastNonEmptyLine + 1);\n}\n\nfunction leadingWhitespace(str) {\n  let i = 0;\n\n  while (i < str.length && isWhiteSpace(str.charCodeAt(i))) {\n    ++i;\n  }\n\n  return i;\n}\n/**\n * @internal\n */\n\n\nexport function isPrintableAsBlockString(value) {\n  if (value === '') {\n    return true; // empty string is printable\n  }\n\n  let isEmptyLine = true;\n  let hasIndent = false;\n  let hasCommonIndent = true;\n  let seenNonEmptyLine = false;\n\n  for (let i = 0; i < value.length; ++i) {\n    switch (value.codePointAt(i)) {\n      case 0x0000:\n      case 0x0001:\n      case 0x0002:\n      case 0x0003:\n      case 0x0004:\n      case 0x0005:\n      case 0x0006:\n      case 0x0007:\n      case 0x0008:\n      case 0x000b:\n      case 0x000c:\n      case 0x000e:\n      case 0x000f:\n        return false;\n      // Has non-printable characters\n\n      case 0x000d:\n        //  \\r\n        return false;\n      // Has \\r or \\r\\n which will be replaced as \\n\n\n      case 10:\n        //  \\n\n        if (isEmptyLine && !seenNonEmptyLine) {\n          return false; // Has leading new line\n        }\n\n        seenNonEmptyLine = true;\n        isEmptyLine = true;\n        hasIndent = false;\n        break;\n\n      case 9: //   \\t\n\n      case 32:\n        //  <space>\n        hasIndent || (hasIndent = isEmptyLine);\n        break;\n\n      default:\n        hasCommonIndent && (hasCommonIndent = hasIndent);\n        isEmptyLine = false;\n    }\n  }\n\n  if (isEmptyLine) {\n    return false; // Has trailing empty lines\n  }\n\n  if (hasCommonIndent && seenNonEmptyLine) {\n    return false; // Has internal indent\n  }\n\n  return true;\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n *\n * @internal\n */\n\nexport function printBlockString(value, options) {\n  const escapedValue = value.replace(/\"\"\"/g, '\\\\\"\"\"'); // Expand a block string's raw value into independent lines.\n\n  const lines = escapedValue.split(/\\r\\n|[\\n\\r]/g);\n  const isSingleLine = lines.length === 1; // If common indentation is found we can fix some of those cases by adding leading new line\n\n  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every(line => line.length === 0 || isWhiteSpace(line.charCodeAt(0))); // Trailing triple quotes just looks confusing but doesn't force trailing new line\n\n  const hasTrailingTripleQuotes = escapedValue.endsWith('\\\\\"\"\"'); // Trailing quote (single or double) or slash forces trailing new line\n\n  const hasTrailingQuote = value.endsWith('\"') && !hasTrailingTripleQuotes;\n  const hasTrailingSlash = value.endsWith('\\\\');\n  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;\n  const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && ( // add leading and trailing new lines only if it improves readability\n  !isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);\n  let result = ''; // Format a multi-line block quote to account for leading space.\n\n  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));\n\n  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {\n    result += '\\n';\n  }\n\n  result += escapedValue;\n\n  if (printAsMultipleLines || forceTrailingNewline) {\n    result += '\\n';\n  }\n\n  return '\"\"\"' + result + '\"\"\"';\n}","map":{"version":3,"sources":["/Users/adammartiska/Projects/eMenu/GUI/eMenu-customer/node_modules/graphql/language/blockString.mjs"],"names":["isWhiteSpace","dedentBlockStringLines","lines","_firstNonEmptyLine2","commonIndent","Number","MAX_SAFE_INTEGER","firstNonEmptyLine","lastNonEmptyLine","i","length","_firstNonEmptyLine","line","indent","leadingWhitespace","map","slice","str","charCodeAt","isPrintableAsBlockString","value","isEmptyLine","hasIndent","hasCommonIndent","seenNonEmptyLine","codePointAt","printBlockString","options","escapedValue","replace","split","isSingleLine","forceLeadingNewLine","every","hasTrailingTripleQuotes","endsWith","hasTrailingQuote","hasTrailingSlash","forceTrailingNewline","printAsMultipleLines","minimize","result","skipLeadingNewLine"],"mappings":"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","sourcesContent":["import { isWhiteSpace } from './characterClasses.mjs';\n/**\n * Produces the value of a block string from its parsed raw value, similar to\n * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.\n *\n * This implements the GraphQL spec's BlockStringValue() static algorithm.\n *\n * @internal\n */\n\nexport function dedentBlockStringLines(lines) {\n  var _firstNonEmptyLine2;\n\n  let commonIndent = Number.MAX_SAFE_INTEGER;\n  let firstNonEmptyLine = null;\n  let lastNonEmptyLine = -1;\n\n  for (let i = 0; i < lines.length; ++i) {\n    var _firstNonEmptyLine;\n\n    const line = lines[i];\n    const indent = leadingWhitespace(line);\n\n    if (indent === line.length) {\n      continue; // skip empty lines\n    }\n\n    firstNonEmptyLine =\n      (_firstNonEmptyLine = firstNonEmptyLine) !== null &&\n      _firstNonEmptyLine !== void 0\n        ? _firstNonEmptyLine\n        : i;\n    lastNonEmptyLine = i;\n\n    if (i !== 0 && indent < commonIndent) {\n      commonIndent = indent;\n    }\n  }\n\n  return lines // Remove common indentation from all lines but first.\n    .map((line, i) => (i === 0 ? line : line.slice(commonIndent))) // Remove leading and trailing blank lines.\n    .slice(\n      (_firstNonEmptyLine2 = firstNonEmptyLine) !== null &&\n        _firstNonEmptyLine2 !== void 0\n        ? _firstNonEmptyLine2\n        : 0,\n      lastNonEmptyLine + 1,\n    );\n}\n\nfunction leadingWhitespace(str) {\n  let i = 0;\n\n  while (i < str.length && isWhiteSpace(str.charCodeAt(i))) {\n    ++i;\n  }\n\n  return i;\n}\n/**\n * @internal\n */\n\nexport function isPrintableAsBlockString(value) {\n  if (value === '') {\n    return true; // empty string is printable\n  }\n\n  let isEmptyLine = true;\n  let hasIndent = false;\n  let hasCommonIndent = true;\n  let seenNonEmptyLine = false;\n\n  for (let i = 0; i < value.length; ++i) {\n    switch (value.codePointAt(i)) {\n      case 0x0000:\n      case 0x0001:\n      case 0x0002:\n      case 0x0003:\n      case 0x0004:\n      case 0x0005:\n      case 0x0006:\n      case 0x0007:\n      case 0x0008:\n      case 0x000b:\n      case 0x000c:\n      case 0x000e:\n      case 0x000f:\n        return false;\n      // Has non-printable characters\n\n      case 0x000d:\n        //  \\r\n        return false;\n      // Has \\r or \\r\\n which will be replaced as \\n\n\n      case 10:\n        //  \\n\n        if (isEmptyLine && !seenNonEmptyLine) {\n          return false; // Has leading new line\n        }\n\n        seenNonEmptyLine = true;\n        isEmptyLine = true;\n        hasIndent = false;\n        break;\n\n      case 9: //   \\t\n\n      case 32:\n        //  <space>\n        hasIndent || (hasIndent = isEmptyLine);\n        break;\n\n      default:\n        hasCommonIndent && (hasCommonIndent = hasIndent);\n        isEmptyLine = false;\n    }\n  }\n\n  if (isEmptyLine) {\n    return false; // Has trailing empty lines\n  }\n\n  if (hasCommonIndent && seenNonEmptyLine) {\n    return false; // Has internal indent\n  }\n\n  return true;\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n *\n * @internal\n */\n\nexport function printBlockString(value, options) {\n  const escapedValue = value.replace(/\"\"\"/g, '\\\\\"\"\"'); // Expand a block string's raw value into independent lines.\n\n  const lines = escapedValue.split(/\\r\\n|[\\n\\r]/g);\n  const isSingleLine = lines.length === 1; // If common indentation is found we can fix some of those cases by adding leading new line\n\n  const forceLeadingNewLine =\n    lines.length > 1 &&\n    lines\n      .slice(1)\n      .every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0))); // Trailing triple quotes just looks confusing but doesn't force trailing new line\n\n  const hasTrailingTripleQuotes = escapedValue.endsWith('\\\\\"\"\"'); // Trailing quote (single or double) or slash forces trailing new line\n\n  const hasTrailingQuote = value.endsWith('\"') && !hasTrailingTripleQuotes;\n  const hasTrailingSlash = value.endsWith('\\\\');\n  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;\n  const printAsMultipleLines =\n    !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability\n    (!isSingleLine ||\n      value.length > 70 ||\n      forceTrailingNewline ||\n      forceLeadingNewLine ||\n      hasTrailingTripleQuotes);\n  let result = ''; // Format a multi-line block quote to account for leading space.\n\n  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));\n\n  if ((printAsMultipleLines && !skipLeadingNewLine) || forceLeadingNewLine) {\n    result += '\\n';\n  }\n\n  result += escapedValue;\n\n  if (printAsMultipleLines || forceTrailingNewline) {\n    result += '\\n';\n  }\n\n  return '\"\"\"' + result + '\"\"\"';\n}\n"]},"metadata":{},"sourceType":"module"}