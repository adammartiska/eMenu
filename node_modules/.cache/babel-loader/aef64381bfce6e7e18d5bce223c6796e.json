{"ast":null,"code":"import { inspect } from '../jsutils/inspect.mjs';\nimport { keyMap } from '../jsutils/keyMap.mjs';\nimport { mapValue } from '../jsutils/mapValue.mjs';\nimport { toObjMap } from '../jsutils/toObjMap.mjs';\nimport { devAssert } from '../jsutils/devAssert.mjs';\nimport { keyValMap } from '../jsutils/keyValMap.mjs';\nimport { instanceOf } from '../jsutils/instanceOf.mjs';\nimport { didYouMean } from '../jsutils/didYouMean.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { identityFunc } from '../jsutils/identityFunc.mjs';\nimport { suggestionList } from '../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { print } from '../language/printer.mjs';\nimport { valueFromASTUntyped } from '../utilities/valueFromASTUntyped.mjs';\nimport { assertName, assertEnumValueName } from './assertName.mjs'; // Predicates & Assertions\n\n/**\n * These are all of the possible kinds of types.\n */\n\nexport function isType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);\n}\nexport function assertType(type) {\n  if (!isType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL type.`);\n  }\n\n  return type;\n}\n/**\n * There are predicates for each kind of GraphQL type.\n */\n\nexport function isScalarType(type) {\n  return instanceOf(type, GraphQLScalarType);\n}\nexport function assertScalarType(type) {\n  if (!isScalarType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL Scalar type.`);\n  }\n\n  return type;\n}\nexport function isObjectType(type) {\n  return instanceOf(type, GraphQLObjectType);\n}\nexport function assertObjectType(type) {\n  if (!isObjectType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL Object type.`);\n  }\n\n  return type;\n}\nexport function isInterfaceType(type) {\n  return instanceOf(type, GraphQLInterfaceType);\n}\nexport function assertInterfaceType(type) {\n  if (!isInterfaceType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL Interface type.`);\n  }\n\n  return type;\n}\nexport function isUnionType(type) {\n  return instanceOf(type, GraphQLUnionType);\n}\nexport function assertUnionType(type) {\n  if (!isUnionType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL Union type.`);\n  }\n\n  return type;\n}\nexport function isEnumType(type) {\n  return instanceOf(type, GraphQLEnumType);\n}\nexport function assertEnumType(type) {\n  if (!isEnumType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL Enum type.`);\n  }\n\n  return type;\n}\nexport function isInputObjectType(type) {\n  return instanceOf(type, GraphQLInputObjectType);\n}\nexport function assertInputObjectType(type) {\n  if (!isInputObjectType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL Input Object type.`);\n  }\n\n  return type;\n}\nexport function isListType(type) {\n  return instanceOf(type, GraphQLList);\n}\nexport function assertListType(type) {\n  if (!isListType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL List type.`);\n  }\n\n  return type;\n}\nexport function isNonNullType(type) {\n  return instanceOf(type, GraphQLNonNull);\n}\nexport function assertNonNullType(type) {\n  if (!isNonNullType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL Non-Null type.`);\n  }\n\n  return type;\n}\n/**\n * These types may be used as input types for arguments and directives.\n */\n\nexport function isInputType(type) {\n  return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);\n}\nexport function assertInputType(type) {\n  if (!isInputType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL input type.`);\n  }\n\n  return type;\n}\n/**\n * These types may be used as output types as the result of fields.\n */\n\nexport function isOutputType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);\n}\nexport function assertOutputType(type) {\n  if (!isOutputType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL output type.`);\n  }\n\n  return type;\n}\n/**\n * These types may describe types which may be leaf values.\n */\n\nexport function isLeafType(type) {\n  return isScalarType(type) || isEnumType(type);\n}\nexport function assertLeafType(type) {\n  if (!isLeafType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL leaf type.`);\n  }\n\n  return type;\n}\n/**\n * These types may describe the parent context of a selection set.\n */\n\nexport function isCompositeType(type) {\n  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);\n}\nexport function assertCompositeType(type) {\n  if (!isCompositeType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL composite type.`);\n  }\n\n  return type;\n}\n/**\n * These types may describe the parent context of a selection set.\n */\n\nexport function isAbstractType(type) {\n  return isInterfaceType(type) || isUnionType(type);\n}\nexport function assertAbstractType(type) {\n  if (!isAbstractType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL abstract type.`);\n  }\n\n  return type;\n}\n/**\n * List Type Wrapper\n *\n * A list is a wrapping type which points to another type.\n * Lists are often created within the context of defining the fields of\n * an object type.\n *\n * Example:\n *\n * ```ts\n * const PersonType = new GraphQLObjectType({\n *   name: 'Person',\n *   fields: () => ({\n *     parents: { type: new GraphQLList(PersonType) },\n *     children: { type: new GraphQLList(PersonType) },\n *   })\n * })\n * ```\n */\n\nexport class GraphQLList {\n  constructor(ofType) {\n    isType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);\n    this.ofType = ofType;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLList';\n  }\n\n  toString() {\n    return '[' + String(this.ofType) + ']';\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n}\n/**\n * Non-Null Type Wrapper\n *\n * A non-null is a wrapping type which points to another type.\n * Non-null types enforce that their values are never null and can ensure\n * an error is raised if this ever occurs during a request. It is useful for\n * fields which you can make a strong guarantee on non-nullability, for example\n * usually the id field of a database row will never be null.\n *\n * Example:\n *\n * ```ts\n * const RowType = new GraphQLObjectType({\n *   name: 'Row',\n *   fields: () => ({\n *     id: { type: new GraphQLNonNull(GraphQLString) },\n *   })\n * })\n * ```\n * Note: the enforcement of non-nullability occurs within the executor.\n */\n\nexport class GraphQLNonNull {\n  constructor(ofType) {\n    isNullableType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL nullable type.`);\n    this.ofType = ofType;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLNonNull';\n  }\n\n  toString() {\n    return String(this.ofType) + '!';\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n}\n/**\n * These types wrap and modify other types\n */\n\nexport function isWrappingType(type) {\n  return isListType(type) || isNonNullType(type);\n}\nexport function assertWrappingType(type) {\n  if (!isWrappingType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL wrapping type.`);\n  }\n\n  return type;\n}\n/**\n * These types can all accept null as a value.\n */\n\nexport function isNullableType(type) {\n  return isType(type) && !isNonNullType(type);\n}\nexport function assertNullableType(type) {\n  if (!isNullableType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL nullable type.`);\n  }\n\n  return type;\n}\nexport function getNullableType(type) {\n  if (type) {\n    return isNonNullType(type) ? type.ofType : type;\n  }\n}\n/**\n * These named types do not include modifiers like List or NonNull.\n */\n\nexport function isNamedType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);\n}\nexport function assertNamedType(type) {\n  if (!isNamedType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL named type.`);\n  }\n\n  return type;\n}\nexport function getNamedType(type) {\n  if (type) {\n    let unwrappedType = type;\n\n    while (isWrappingType(unwrappedType)) {\n      unwrappedType = unwrappedType.ofType;\n    }\n\n    return unwrappedType;\n  }\n}\n/**\n * Used while defining GraphQL types to allow for circular references in\n * otherwise immutable type definitions.\n */\n\nfunction resolveReadonlyArrayThunk(thunk) {\n  return typeof thunk === 'function' ? thunk() : thunk;\n}\n\nfunction resolveObjMapThunk(thunk) {\n  return typeof thunk === 'function' ? thunk() : thunk;\n}\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\n\n/**\n * Scalar Type Definition\n *\n * The leaf values of any request and input values to arguments are\n * Scalars (or Enums) and are defined with a name and a series of functions\n * used to parse input from ast or variables and to ensure validity.\n *\n * If a type's serialize function does not return a value (i.e. it returns\n * `undefined`) then an error will be raised and a `null` value will be returned\n * in the response. If the serialize function returns `null`, then no error will\n * be included in the response.\n *\n * Example:\n *\n * ```ts\n * const OddType = new GraphQLScalarType({\n *   name: 'Odd',\n *   serialize(value) {\n *     if (value % 2 === 1) {\n *       return value;\n *     }\n *   }\n * });\n * ```\n */\n\n\nexport class GraphQLScalarType {\n  constructor(config) {\n    var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;\n\n    const parseValue = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.specifiedByURL = config.specifiedByURL;\n    this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;\n    this.parseValue = parseValue;\n    this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue(valueFromASTUntyped(node, variables));\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];\n    config.specifiedByURL == null || typeof config.specifiedByURL === 'string' || devAssert(false, `${this.name} must provide \"specifiedByURL\" as a string, ` + `but got: ${inspect(config.specifiedByURL)}.`);\n    config.serialize == null || typeof config.serialize === 'function' || devAssert(false, `${this.name} must provide \"serialize\" function. If this custom Scalar is also used as an input type, ensure \"parseValue\" and \"parseLiteral\" functions are also provided.`);\n\n    if (config.parseLiteral) {\n      typeof config.parseValue === 'function' && typeof config.parseLiteral === 'function' || devAssert(false, `${this.name} must provide both \"parseValue\" and \"parseLiteral\" functions.`);\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLScalarType';\n  }\n\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      specifiedByURL: this.specifiedByURL,\n      serialize: this.serialize,\n      parseValue: this.parseValue,\n      parseLiteral: this.parseLiteral,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes\n    };\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n}\n/**\n * Object Type Definition\n *\n * Almost all of the GraphQL types you define will be object types. Object types\n * have a name, but most importantly describe their fields.\n *\n * Example:\n *\n * ```ts\n * const AddressType = new GraphQLObjectType({\n *   name: 'Address',\n *   fields: {\n *     street: { type: GraphQLString },\n *     number: { type: GraphQLInt },\n *     formatted: {\n *       type: GraphQLString,\n *       resolve(obj) {\n *         return obj.number + ' ' + obj.street\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * When two types need to refer to each other, or a type needs to refer to\n * itself in a field, you can use a function expression (aka a closure or a\n * thunk) to supply the fields lazily.\n *\n * Example:\n *\n * ```ts\n * const PersonType = new GraphQLObjectType({\n *   name: 'Person',\n *   fields: () => ({\n *     name: { type: GraphQLString },\n *     bestFriend: { type: PersonType },\n *   })\n * });\n * ```\n */\n\nexport class GraphQLObjectType {\n  constructor(config) {\n    var _config$extensionASTN2;\n\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.isTypeOf = config.isTypeOf;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];\n\n    this._fields = () => defineFieldMap(config);\n\n    this._interfaces = () => defineInterfaces(config);\n\n    config.isTypeOf == null || typeof config.isTypeOf === 'function' || devAssert(false, `${this.name} must provide \"isTypeOf\" as a function, ` + `but got: ${inspect(config.isTypeOf)}.`);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLObjectType';\n  }\n\n  getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  }\n\n  getInterfaces() {\n    if (typeof this._interfaces === 'function') {\n      this._interfaces = this._interfaces();\n    }\n\n    return this._interfaces;\n  }\n\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      interfaces: this.getInterfaces(),\n      fields: fieldsToFieldsConfig(this.getFields()),\n      isTypeOf: this.isTypeOf,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes\n    };\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n}\n\nfunction defineInterfaces(config) {\n  var _config$interfaces;\n\n  const interfaces = resolveReadonlyArrayThunk((_config$interfaces = config.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []);\n  Array.isArray(interfaces) || devAssert(false, `${config.name} interfaces must be an Array or a function which returns an Array.`);\n  return interfaces;\n}\n\nfunction defineFieldMap(config) {\n  const fieldMap = resolveObjMapThunk(config.fields);\n  isPlainObj(fieldMap) || devAssert(false, `${config.name} fields must be an object with field names as keys or a function which returns such an object.`);\n  return mapValue(fieldMap, (fieldConfig, fieldName) => {\n    var _fieldConfig$args;\n\n    isPlainObj(fieldConfig) || devAssert(false, `${config.name}.${fieldName} field config must be an object.`);\n    fieldConfig.resolve == null || typeof fieldConfig.resolve === 'function' || devAssert(false, `${config.name}.${fieldName} field resolver must be a function if ` + `provided, but got: ${inspect(fieldConfig.resolve)}.`);\n    const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};\n    isPlainObj(argsConfig) || devAssert(false, `${config.name}.${fieldName} args must be an object with argument names as keys.`);\n    return {\n      name: assertName(fieldName),\n      description: fieldConfig.description,\n      type: fieldConfig.type,\n      args: defineArguments(argsConfig),\n      resolve: fieldConfig.resolve,\n      subscribe: fieldConfig.subscribe,\n      deprecationReason: fieldConfig.deprecationReason,\n      extensions: toObjMap(fieldConfig.extensions),\n      astNode: fieldConfig.astNode\n    };\n  });\n}\n\nexport function defineArguments(config) {\n  return Object.entries(config).map(([argName, argConfig]) => ({\n    name: assertName(argName),\n    description: argConfig.description,\n    type: argConfig.type,\n    defaultValue: argConfig.defaultValue,\n    deprecationReason: argConfig.deprecationReason,\n    extensions: toObjMap(argConfig.extensions),\n    astNode: argConfig.astNode\n  }));\n}\n\nfunction isPlainObj(obj) {\n  return isObjectLike(obj) && !Array.isArray(obj);\n}\n\nfunction fieldsToFieldsConfig(fields) {\n  return mapValue(fields, field => ({\n    description: field.description,\n    type: field.type,\n    args: argsToArgsConfig(field.args),\n    resolve: field.resolve,\n    subscribe: field.subscribe,\n    deprecationReason: field.deprecationReason,\n    extensions: field.extensions,\n    astNode: field.astNode\n  }));\n}\n/**\n * @internal\n */\n\n\nexport function argsToArgsConfig(args) {\n  return keyValMap(args, arg => arg.name, arg => ({\n    description: arg.description,\n    type: arg.type,\n    defaultValue: arg.defaultValue,\n    deprecationReason: arg.deprecationReason,\n    extensions: arg.extensions,\n    astNode: arg.astNode\n  }));\n}\nexport function isRequiredArgument(arg) {\n  return isNonNullType(arg.type) && arg.defaultValue === undefined;\n}\n/**\n * Interface Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Interface type\n * is used to describe what types are possible, what fields are in common across\n * all types, as well as a function to determine which type is actually used\n * when the field is resolved.\n *\n * Example:\n *\n * ```ts\n * const EntityType = new GraphQLInterfaceType({\n *   name: 'Entity',\n *   fields: {\n *     name: { type: GraphQLString }\n *   }\n * });\n * ```\n */\n\nexport class GraphQLInterfaceType {\n  constructor(config) {\n    var _config$extensionASTN3;\n\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.resolveType = config.resolveType;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];\n    this._fields = defineFieldMap.bind(undefined, config);\n    this._interfaces = defineInterfaces.bind(undefined, config);\n    config.resolveType == null || typeof config.resolveType === 'function' || devAssert(false, `${this.name} must provide \"resolveType\" as a function, ` + `but got: ${inspect(config.resolveType)}.`);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLInterfaceType';\n  }\n\n  getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  }\n\n  getInterfaces() {\n    if (typeof this._interfaces === 'function') {\n      this._interfaces = this._interfaces();\n    }\n\n    return this._interfaces;\n  }\n\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      interfaces: this.getInterfaces(),\n      fields: fieldsToFieldsConfig(this.getFields()),\n      resolveType: this.resolveType,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes\n    };\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n}\n/**\n * Union Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Union type\n * is used to describe what types are possible as well as providing a function\n * to determine which type is actually used when the field is resolved.\n *\n * Example:\n *\n * ```ts\n * const PetType = new GraphQLUnionType({\n *   name: 'Pet',\n *   types: [ DogType, CatType ],\n *   resolveType(value) {\n *     if (value instanceof Dog) {\n *       return DogType;\n *     }\n *     if (value instanceof Cat) {\n *       return CatType;\n *     }\n *   }\n * });\n * ```\n */\n\nexport class GraphQLUnionType {\n  constructor(config) {\n    var _config$extensionASTN4;\n\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.resolveType = config.resolveType;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];\n    this._types = defineTypes.bind(undefined, config);\n    config.resolveType == null || typeof config.resolveType === 'function' || devAssert(false, `${this.name} must provide \"resolveType\" as a function, ` + `but got: ${inspect(config.resolveType)}.`);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLUnionType';\n  }\n\n  getTypes() {\n    if (typeof this._types === 'function') {\n      this._types = this._types();\n    }\n\n    return this._types;\n  }\n\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      types: this.getTypes(),\n      resolveType: this.resolveType,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes\n    };\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n}\n\nfunction defineTypes(config) {\n  const types = resolveReadonlyArrayThunk(config.types);\n  Array.isArray(types) || devAssert(false, `Must provide Array of types or a function which returns such an array for Union ${config.name}.`);\n  return types;\n}\n/**\n * Enum Type Definition\n *\n * Some leaf values of requests and input values are Enums. GraphQL serializes\n * Enum values as strings, however internally Enums can be represented by any\n * kind of type, often integers.\n *\n * Example:\n *\n * ```ts\n * const RGBType = new GraphQLEnumType({\n *   name: 'RGB',\n *   values: {\n *     RED: { value: 0 },\n *     GREEN: { value: 1 },\n *     BLUE: { value: 2 }\n *   }\n * });\n * ```\n *\n * Note: If a value is not provided in a definition, the name of the enum value\n * will be used as its internal value.\n */\n\n\nexport class GraphQLEnumType {\n  /* <T> */\n  constructor(config) {\n    var _config$extensionASTN5;\n\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];\n    this._values = defineEnumValues(this.name, config.values);\n    this._valueLookup = new Map(this._values.map(enumValue => [enumValue.value, enumValue]));\n    this._nameLookup = keyMap(this._values, value => value.name);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLEnumType';\n  }\n\n  getValues() {\n    return this._values;\n  }\n\n  getValue(name) {\n    return this._nameLookup[name];\n  }\n\n  serialize(outputValue) {\n    const enumValue = this._valueLookup.get(outputValue);\n\n    if (enumValue === undefined) {\n      throw new GraphQLError(`Enum \"${this.name}\" cannot represent value: ${inspect(outputValue)}`);\n    }\n\n    return enumValue.name;\n  }\n\n  parseValue(inputValue)\n  /* T */\n  {\n    if (typeof inputValue !== 'string') {\n      const valueStr = inspect(inputValue);\n      throw new GraphQLError(`Enum \"${this.name}\" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr));\n    }\n\n    const enumValue = this.getValue(inputValue);\n\n    if (enumValue == null) {\n      throw new GraphQLError(`Value \"${inputValue}\" does not exist in \"${this.name}\" enum.` + didYouMeanEnumValue(this, inputValue));\n    }\n\n    return enumValue.value;\n  }\n\n  parseLiteral(valueNode, _variables)\n  /* T */\n  {\n    // Note: variables will be resolved to a value before calling this function.\n    if (valueNode.kind !== Kind.ENUM) {\n      const valueStr = print(valueNode);\n      throw new GraphQLError(`Enum \"${this.name}\" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr), valueNode);\n    }\n\n    const enumValue = this.getValue(valueNode.value);\n\n    if (enumValue == null) {\n      const valueStr = print(valueNode);\n      throw new GraphQLError(`Value \"${valueStr}\" does not exist in \"${this.name}\" enum.` + didYouMeanEnumValue(this, valueStr), valueNode);\n    }\n\n    return enumValue.value;\n  }\n\n  toConfig() {\n    const values = keyValMap(this.getValues(), value => value.name, value => ({\n      description: value.description,\n      value: value.value,\n      deprecationReason: value.deprecationReason,\n      extensions: value.extensions,\n      astNode: value.astNode\n    }));\n    return {\n      name: this.name,\n      description: this.description,\n      values,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes\n    };\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n}\n\nfunction didYouMeanEnumValue(enumType, unknownValueStr) {\n  const allNames = enumType.getValues().map(value => value.name);\n  const suggestedValues = suggestionList(unknownValueStr, allNames);\n  return didYouMean('the enum value', suggestedValues);\n}\n\nfunction defineEnumValues(typeName, valueMap) {\n  isPlainObj(valueMap) || devAssert(false, `${typeName} values must be an object with value names as keys.`);\n  return Object.entries(valueMap).map(([valueName, valueConfig]) => {\n    isPlainObj(valueConfig) || devAssert(false, `${typeName}.${valueName} must refer to an object with a \"value\" key ` + `representing an internal value but got: ${inspect(valueConfig)}.`);\n    return {\n      name: assertEnumValueName(valueName),\n      description: valueConfig.description,\n      value: valueConfig.value !== undefined ? valueConfig.value : valueName,\n      deprecationReason: valueConfig.deprecationReason,\n      extensions: toObjMap(valueConfig.extensions),\n      astNode: valueConfig.astNode\n    };\n  });\n}\n/**\n * Input Object Type Definition\n *\n * An input object defines a structured collection of fields which may be\n * supplied to a field argument.\n *\n * Using `NonNull` will ensure that a value must be provided by the query\n *\n * Example:\n *\n * ```ts\n * const GeoPoint = new GraphQLInputObjectType({\n *   name: 'GeoPoint',\n *   fields: {\n *     lat: { type: new GraphQLNonNull(GraphQLFloat) },\n *     lon: { type: new GraphQLNonNull(GraphQLFloat) },\n *     alt: { type: GraphQLFloat, defaultValue: 0 },\n *   }\n * });\n * ```\n */\n\n\nexport class GraphQLInputObjectType {\n  constructor(config) {\n    var _config$extensionASTN6;\n\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];\n    this._fields = defineInputFieldMap.bind(undefined, config);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLInputObjectType';\n  }\n\n  getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  }\n\n  toConfig() {\n    const fields = mapValue(this.getFields(), field => ({\n      description: field.description,\n      type: field.type,\n      defaultValue: field.defaultValue,\n      deprecationReason: field.deprecationReason,\n      extensions: field.extensions,\n      astNode: field.astNode\n    }));\n    return {\n      name: this.name,\n      description: this.description,\n      fields,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes\n    };\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n}\n\nfunction defineInputFieldMap(config) {\n  const fieldMap = resolveObjMapThunk(config.fields);\n  isPlainObj(fieldMap) || devAssert(false, `${config.name} fields must be an object with field names as keys or a function which returns such an object.`);\n  return mapValue(fieldMap, (fieldConfig, fieldName) => {\n    !('resolve' in fieldConfig) || devAssert(false, `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`);\n    return {\n      name: assertName(fieldName),\n      description: fieldConfig.description,\n      type: fieldConfig.type,\n      defaultValue: fieldConfig.defaultValue,\n      deprecationReason: fieldConfig.deprecationReason,\n      extensions: toObjMap(fieldConfig.extensions),\n      astNode: fieldConfig.astNode\n    };\n  });\n}\n\nexport function isRequiredInputField(field) {\n  return isNonNullType(field.type) && field.defaultValue === undefined;\n}","map":{"version":3,"sources":["/Users/adammartiska/Projects/eMenu/GUI/eMenu-customer/node_modules/graphql/type/definition.mjs"],"names":["inspect","keyMap","mapValue","toObjMap","devAssert","keyValMap","instanceOf","didYouMean","isObjectLike","identityFunc","suggestionList","GraphQLError","Kind","print","valueFromASTUntyped","assertName","assertEnumValueName","isType","type","isScalarType","isObjectType","isInterfaceType","isUnionType","isEnumType","isInputObjectType","isListType","isNonNullType","assertType","Error","GraphQLScalarType","assertScalarType","GraphQLObjectType","assertObjectType","GraphQLInterfaceType","assertInterfaceType","GraphQLUnionType","assertUnionType","GraphQLEnumType","assertEnumType","GraphQLInputObjectType","assertInputObjectType","GraphQLList","assertListType","GraphQLNonNull","assertNonNullType","isInputType","isWrappingType","ofType","assertInputType","isOutputType","assertOutputType","isLeafType","assertLeafType","isCompositeType","assertCompositeType","isAbstractType","assertAbstractType","constructor","Symbol","toStringTag","toString","String","toJSON","isNullableType","assertWrappingType","assertNullableType","getNullableType","isNamedType","assertNamedType","getNamedType","unwrappedType","resolveReadonlyArrayThunk","thunk","resolveObjMapThunk","config","_config$parseValue","_config$serialize","_config$parseLiteral","_config$extensionASTN","parseValue","name","description","specifiedByURL","serialize","parseLiteral","node","variables","extensions","astNode","extensionASTNodes","toConfig","_config$extensionASTN2","isTypeOf","_fields","defineFieldMap","_interfaces","defineInterfaces","getFields","getInterfaces","interfaces","fields","fieldsToFieldsConfig","_config$interfaces","Array","isArray","fieldMap","isPlainObj","fieldConfig","fieldName","_fieldConfig$args","resolve","argsConfig","args","defineArguments","subscribe","deprecationReason","Object","entries","map","argName","argConfig","defaultValue","obj","field","argsToArgsConfig","arg","isRequiredArgument","undefined","_config$extensionASTN3","resolveType","bind","_config$extensionASTN4","_types","defineTypes","getTypes","types","_config$extensionASTN5","_values","defineEnumValues","values","_valueLookup","Map","enumValue","value","_nameLookup","getValues","getValue","outputValue","get","inputValue","valueStr","didYouMeanEnumValue","valueNode","_variables","kind","ENUM","enumType","unknownValueStr","allNames","suggestedValues","typeName","valueMap","valueName","valueConfig","_config$extensionASTN6","defineInputFieldMap","isRequiredInputField"],"mappings":"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","sourcesContent":["import { inspect } from '../jsutils/inspect.mjs';\nimport { keyMap } from '../jsutils/keyMap.mjs';\nimport { mapValue } from '../jsutils/mapValue.mjs';\nimport { toObjMap } from '../jsutils/toObjMap.mjs';\nimport { devAssert } from '../jsutils/devAssert.mjs';\nimport { keyValMap } from '../jsutils/keyValMap.mjs';\nimport { instanceOf } from '../jsutils/instanceOf.mjs';\nimport { didYouMean } from '../jsutils/didYouMean.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { identityFunc } from '../jsutils/identityFunc.mjs';\nimport { suggestionList } from '../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { print } from '../language/printer.mjs';\nimport { valueFromASTUntyped } from '../utilities/valueFromASTUntyped.mjs';\nimport { assertName, assertEnumValueName } from './assertName.mjs'; // Predicates & Assertions\n\n/**\n * These are all of the possible kinds of types.\n */\n\nexport function isType(type) {\n  return (\n    isScalarType(type) ||\n    isObjectType(type) ||\n    isInterfaceType(type) ||\n    isUnionType(type) ||\n    isEnumType(type) ||\n    isInputObjectType(type) ||\n    isListType(type) ||\n    isNonNullType(type)\n  );\n}\nexport function assertType(type) {\n  if (!isType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL type.`);\n  }\n\n  return type;\n}\n/**\n * There are predicates for each kind of GraphQL type.\n */\n\nexport function isScalarType(type) {\n  return instanceOf(type, GraphQLScalarType);\n}\nexport function assertScalarType(type) {\n  if (!isScalarType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL Scalar type.`);\n  }\n\n  return type;\n}\nexport function isObjectType(type) {\n  return instanceOf(type, GraphQLObjectType);\n}\nexport function assertObjectType(type) {\n  if (!isObjectType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL Object type.`);\n  }\n\n  return type;\n}\nexport function isInterfaceType(type) {\n  return instanceOf(type, GraphQLInterfaceType);\n}\nexport function assertInterfaceType(type) {\n  if (!isInterfaceType(type)) {\n    throw new Error(\n      `Expected ${inspect(type)} to be a GraphQL Interface type.`,\n    );\n  }\n\n  return type;\n}\nexport function isUnionType(type) {\n  return instanceOf(type, GraphQLUnionType);\n}\nexport function assertUnionType(type) {\n  if (!isUnionType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL Union type.`);\n  }\n\n  return type;\n}\nexport function isEnumType(type) {\n  return instanceOf(type, GraphQLEnumType);\n}\nexport function assertEnumType(type) {\n  if (!isEnumType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL Enum type.`);\n  }\n\n  return type;\n}\nexport function isInputObjectType(type) {\n  return instanceOf(type, GraphQLInputObjectType);\n}\nexport function assertInputObjectType(type) {\n  if (!isInputObjectType(type)) {\n    throw new Error(\n      `Expected ${inspect(type)} to be a GraphQL Input Object type.`,\n    );\n  }\n\n  return type;\n}\nexport function isListType(type) {\n  return instanceOf(type, GraphQLList);\n}\nexport function assertListType(type) {\n  if (!isListType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL List type.`);\n  }\n\n  return type;\n}\nexport function isNonNullType(type) {\n  return instanceOf(type, GraphQLNonNull);\n}\nexport function assertNonNullType(type) {\n  if (!isNonNullType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL Non-Null type.`);\n  }\n\n  return type;\n}\n/**\n * These types may be used as input types for arguments and directives.\n */\n\nexport function isInputType(type) {\n  return (\n    isScalarType(type) ||\n    isEnumType(type) ||\n    isInputObjectType(type) ||\n    (isWrappingType(type) && isInputType(type.ofType))\n  );\n}\nexport function assertInputType(type) {\n  if (!isInputType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL input type.`);\n  }\n\n  return type;\n}\n/**\n * These types may be used as output types as the result of fields.\n */\n\nexport function isOutputType(type) {\n  return (\n    isScalarType(type) ||\n    isObjectType(type) ||\n    isInterfaceType(type) ||\n    isUnionType(type) ||\n    isEnumType(type) ||\n    (isWrappingType(type) && isOutputType(type.ofType))\n  );\n}\nexport function assertOutputType(type) {\n  if (!isOutputType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL output type.`);\n  }\n\n  return type;\n}\n/**\n * These types may describe types which may be leaf values.\n */\n\nexport function isLeafType(type) {\n  return isScalarType(type) || isEnumType(type);\n}\nexport function assertLeafType(type) {\n  if (!isLeafType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL leaf type.`);\n  }\n\n  return type;\n}\n/**\n * These types may describe the parent context of a selection set.\n */\n\nexport function isCompositeType(type) {\n  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);\n}\nexport function assertCompositeType(type) {\n  if (!isCompositeType(type)) {\n    throw new Error(\n      `Expected ${inspect(type)} to be a GraphQL composite type.`,\n    );\n  }\n\n  return type;\n}\n/**\n * These types may describe the parent context of a selection set.\n */\n\nexport function isAbstractType(type) {\n  return isInterfaceType(type) || isUnionType(type);\n}\nexport function assertAbstractType(type) {\n  if (!isAbstractType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL abstract type.`);\n  }\n\n  return type;\n}\n/**\n * List Type Wrapper\n *\n * A list is a wrapping type which points to another type.\n * Lists are often created within the context of defining the fields of\n * an object type.\n *\n * Example:\n *\n * ```ts\n * const PersonType = new GraphQLObjectType({\n *   name: 'Person',\n *   fields: () => ({\n *     parents: { type: new GraphQLList(PersonType) },\n *     children: { type: new GraphQLList(PersonType) },\n *   })\n * })\n * ```\n */\n\nexport class GraphQLList {\n  constructor(ofType) {\n    isType(ofType) ||\n      devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);\n    this.ofType = ofType;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLList';\n  }\n\n  toString() {\n    return '[' + String(this.ofType) + ']';\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n}\n/**\n * Non-Null Type Wrapper\n *\n * A non-null is a wrapping type which points to another type.\n * Non-null types enforce that their values are never null and can ensure\n * an error is raised if this ever occurs during a request. It is useful for\n * fields which you can make a strong guarantee on non-nullability, for example\n * usually the id field of a database row will never be null.\n *\n * Example:\n *\n * ```ts\n * const RowType = new GraphQLObjectType({\n *   name: 'Row',\n *   fields: () => ({\n *     id: { type: new GraphQLNonNull(GraphQLString) },\n *   })\n * })\n * ```\n * Note: the enforcement of non-nullability occurs within the executor.\n */\n\nexport class GraphQLNonNull {\n  constructor(ofType) {\n    isNullableType(ofType) ||\n      devAssert(\n        false,\n        `Expected ${inspect(ofType)} to be a GraphQL nullable type.`,\n      );\n    this.ofType = ofType;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLNonNull';\n  }\n\n  toString() {\n    return String(this.ofType) + '!';\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n}\n/**\n * These types wrap and modify other types\n */\n\nexport function isWrappingType(type) {\n  return isListType(type) || isNonNullType(type);\n}\nexport function assertWrappingType(type) {\n  if (!isWrappingType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL wrapping type.`);\n  }\n\n  return type;\n}\n/**\n * These types can all accept null as a value.\n */\n\nexport function isNullableType(type) {\n  return isType(type) && !isNonNullType(type);\n}\nexport function assertNullableType(type) {\n  if (!isNullableType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL nullable type.`);\n  }\n\n  return type;\n}\nexport function getNullableType(type) {\n  if (type) {\n    return isNonNullType(type) ? type.ofType : type;\n  }\n}\n/**\n * These named types do not include modifiers like List or NonNull.\n */\n\nexport function isNamedType(type) {\n  return (\n    isScalarType(type) ||\n    isObjectType(type) ||\n    isInterfaceType(type) ||\n    isUnionType(type) ||\n    isEnumType(type) ||\n    isInputObjectType(type)\n  );\n}\nexport function assertNamedType(type) {\n  if (!isNamedType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL named type.`);\n  }\n\n  return type;\n}\nexport function getNamedType(type) {\n  if (type) {\n    let unwrappedType = type;\n\n    while (isWrappingType(unwrappedType)) {\n      unwrappedType = unwrappedType.ofType;\n    }\n\n    return unwrappedType;\n  }\n}\n/**\n * Used while defining GraphQL types to allow for circular references in\n * otherwise immutable type definitions.\n */\n\nfunction resolveReadonlyArrayThunk(thunk) {\n  return typeof thunk === 'function' ? thunk() : thunk;\n}\n\nfunction resolveObjMapThunk(thunk) {\n  return typeof thunk === 'function' ? thunk() : thunk;\n}\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\n\n/**\n * Scalar Type Definition\n *\n * The leaf values of any request and input values to arguments are\n * Scalars (or Enums) and are defined with a name and a series of functions\n * used to parse input from ast or variables and to ensure validity.\n *\n * If a type's serialize function does not return a value (i.e. it returns\n * `undefined`) then an error will be raised and a `null` value will be returned\n * in the response. If the serialize function returns `null`, then no error will\n * be included in the response.\n *\n * Example:\n *\n * ```ts\n * const OddType = new GraphQLScalarType({\n *   name: 'Odd',\n *   serialize(value) {\n *     if (value % 2 === 1) {\n *       return value;\n *     }\n *   }\n * });\n * ```\n */\nexport class GraphQLScalarType {\n  constructor(config) {\n    var _config$parseValue,\n      _config$serialize,\n      _config$parseLiteral,\n      _config$extensionASTN;\n\n    const parseValue =\n      (_config$parseValue = config.parseValue) !== null &&\n      _config$parseValue !== void 0\n        ? _config$parseValue\n        : identityFunc;\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.specifiedByURL = config.specifiedByURL;\n    this.serialize =\n      (_config$serialize = config.serialize) !== null &&\n      _config$serialize !== void 0\n        ? _config$serialize\n        : identityFunc;\n    this.parseValue = parseValue;\n    this.parseLiteral =\n      (_config$parseLiteral = config.parseLiteral) !== null &&\n      _config$parseLiteral !== void 0\n        ? _config$parseLiteral\n        : (node, variables) => parseValue(valueFromASTUntyped(node, variables));\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes =\n      (_config$extensionASTN = config.extensionASTNodes) !== null &&\n      _config$extensionASTN !== void 0\n        ? _config$extensionASTN\n        : [];\n    config.specifiedByURL == null ||\n      typeof config.specifiedByURL === 'string' ||\n      devAssert(\n        false,\n        `${this.name} must provide \"specifiedByURL\" as a string, ` +\n          `but got: ${inspect(config.specifiedByURL)}.`,\n      );\n    config.serialize == null ||\n      typeof config.serialize === 'function' ||\n      devAssert(\n        false,\n        `${this.name} must provide \"serialize\" function. If this custom Scalar is also used as an input type, ensure \"parseValue\" and \"parseLiteral\" functions are also provided.`,\n      );\n\n    if (config.parseLiteral) {\n      (typeof config.parseValue === 'function' &&\n        typeof config.parseLiteral === 'function') ||\n        devAssert(\n          false,\n          `${this.name} must provide both \"parseValue\" and \"parseLiteral\" functions.`,\n        );\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLScalarType';\n  }\n\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      specifiedByURL: this.specifiedByURL,\n      serialize: this.serialize,\n      parseValue: this.parseValue,\n      parseLiteral: this.parseLiteral,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n    };\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n}\n\n/**\n * Object Type Definition\n *\n * Almost all of the GraphQL types you define will be object types. Object types\n * have a name, but most importantly describe their fields.\n *\n * Example:\n *\n * ```ts\n * const AddressType = new GraphQLObjectType({\n *   name: 'Address',\n *   fields: {\n *     street: { type: GraphQLString },\n *     number: { type: GraphQLInt },\n *     formatted: {\n *       type: GraphQLString,\n *       resolve(obj) {\n *         return obj.number + ' ' + obj.street\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * When two types need to refer to each other, or a type needs to refer to\n * itself in a field, you can use a function expression (aka a closure or a\n * thunk) to supply the fields lazily.\n *\n * Example:\n *\n * ```ts\n * const PersonType = new GraphQLObjectType({\n *   name: 'Person',\n *   fields: () => ({\n *     name: { type: GraphQLString },\n *     bestFriend: { type: PersonType },\n *   })\n * });\n * ```\n */\nexport class GraphQLObjectType {\n  constructor(config) {\n    var _config$extensionASTN2;\n\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.isTypeOf = config.isTypeOf;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes =\n      (_config$extensionASTN2 = config.extensionASTNodes) !== null &&\n      _config$extensionASTN2 !== void 0\n        ? _config$extensionASTN2\n        : [];\n\n    this._fields = () => defineFieldMap(config);\n\n    this._interfaces = () => defineInterfaces(config);\n\n    config.isTypeOf == null ||\n      typeof config.isTypeOf === 'function' ||\n      devAssert(\n        false,\n        `${this.name} must provide \"isTypeOf\" as a function, ` +\n          `but got: ${inspect(config.isTypeOf)}.`,\n      );\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLObjectType';\n  }\n\n  getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  }\n\n  getInterfaces() {\n    if (typeof this._interfaces === 'function') {\n      this._interfaces = this._interfaces();\n    }\n\n    return this._interfaces;\n  }\n\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      interfaces: this.getInterfaces(),\n      fields: fieldsToFieldsConfig(this.getFields()),\n      isTypeOf: this.isTypeOf,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n    };\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n}\n\nfunction defineInterfaces(config) {\n  var _config$interfaces;\n\n  const interfaces = resolveReadonlyArrayThunk(\n    (_config$interfaces = config.interfaces) !== null &&\n      _config$interfaces !== void 0\n      ? _config$interfaces\n      : [],\n  );\n  Array.isArray(interfaces) ||\n    devAssert(\n      false,\n      `${config.name} interfaces must be an Array or a function which returns an Array.`,\n    );\n  return interfaces;\n}\n\nfunction defineFieldMap(config) {\n  const fieldMap = resolveObjMapThunk(config.fields);\n  isPlainObj(fieldMap) ||\n    devAssert(\n      false,\n      `${config.name} fields must be an object with field names as keys or a function which returns such an object.`,\n    );\n  return mapValue(fieldMap, (fieldConfig, fieldName) => {\n    var _fieldConfig$args;\n\n    isPlainObj(fieldConfig) ||\n      devAssert(\n        false,\n        `${config.name}.${fieldName} field config must be an object.`,\n      );\n    fieldConfig.resolve == null ||\n      typeof fieldConfig.resolve === 'function' ||\n      devAssert(\n        false,\n        `${config.name}.${fieldName} field resolver must be a function if ` +\n          `provided, but got: ${inspect(fieldConfig.resolve)}.`,\n      );\n    const argsConfig =\n      (_fieldConfig$args = fieldConfig.args) !== null &&\n      _fieldConfig$args !== void 0\n        ? _fieldConfig$args\n        : {};\n    isPlainObj(argsConfig) ||\n      devAssert(\n        false,\n        `${config.name}.${fieldName} args must be an object with argument names as keys.`,\n      );\n    return {\n      name: assertName(fieldName),\n      description: fieldConfig.description,\n      type: fieldConfig.type,\n      args: defineArguments(argsConfig),\n      resolve: fieldConfig.resolve,\n      subscribe: fieldConfig.subscribe,\n      deprecationReason: fieldConfig.deprecationReason,\n      extensions: toObjMap(fieldConfig.extensions),\n      astNode: fieldConfig.astNode,\n    };\n  });\n}\n\nexport function defineArguments(config) {\n  return Object.entries(config).map(([argName, argConfig]) => ({\n    name: assertName(argName),\n    description: argConfig.description,\n    type: argConfig.type,\n    defaultValue: argConfig.defaultValue,\n    deprecationReason: argConfig.deprecationReason,\n    extensions: toObjMap(argConfig.extensions),\n    astNode: argConfig.astNode,\n  }));\n}\n\nfunction isPlainObj(obj) {\n  return isObjectLike(obj) && !Array.isArray(obj);\n}\n\nfunction fieldsToFieldsConfig(fields) {\n  return mapValue(fields, (field) => ({\n    description: field.description,\n    type: field.type,\n    args: argsToArgsConfig(field.args),\n    resolve: field.resolve,\n    subscribe: field.subscribe,\n    deprecationReason: field.deprecationReason,\n    extensions: field.extensions,\n    astNode: field.astNode,\n  }));\n}\n/**\n * @internal\n */\n\nexport function argsToArgsConfig(args) {\n  return keyValMap(\n    args,\n    (arg) => arg.name,\n    (arg) => ({\n      description: arg.description,\n      type: arg.type,\n      defaultValue: arg.defaultValue,\n      deprecationReason: arg.deprecationReason,\n      extensions: arg.extensions,\n      astNode: arg.astNode,\n    }),\n  );\n}\nexport function isRequiredArgument(arg) {\n  return isNonNullType(arg.type) && arg.defaultValue === undefined;\n}\n\n/**\n * Interface Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Interface type\n * is used to describe what types are possible, what fields are in common across\n * all types, as well as a function to determine which type is actually used\n * when the field is resolved.\n *\n * Example:\n *\n * ```ts\n * const EntityType = new GraphQLInterfaceType({\n *   name: 'Entity',\n *   fields: {\n *     name: { type: GraphQLString }\n *   }\n * });\n * ```\n */\nexport class GraphQLInterfaceType {\n  constructor(config) {\n    var _config$extensionASTN3;\n\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.resolveType = config.resolveType;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes =\n      (_config$extensionASTN3 = config.extensionASTNodes) !== null &&\n      _config$extensionASTN3 !== void 0\n        ? _config$extensionASTN3\n        : [];\n    this._fields = defineFieldMap.bind(undefined, config);\n    this._interfaces = defineInterfaces.bind(undefined, config);\n    config.resolveType == null ||\n      typeof config.resolveType === 'function' ||\n      devAssert(\n        false,\n        `${this.name} must provide \"resolveType\" as a function, ` +\n          `but got: ${inspect(config.resolveType)}.`,\n      );\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLInterfaceType';\n  }\n\n  getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  }\n\n  getInterfaces() {\n    if (typeof this._interfaces === 'function') {\n      this._interfaces = this._interfaces();\n    }\n\n    return this._interfaces;\n  }\n\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      interfaces: this.getInterfaces(),\n      fields: fieldsToFieldsConfig(this.getFields()),\n      resolveType: this.resolveType,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n    };\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n}\n\n/**\n * Union Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Union type\n * is used to describe what types are possible as well as providing a function\n * to determine which type is actually used when the field is resolved.\n *\n * Example:\n *\n * ```ts\n * const PetType = new GraphQLUnionType({\n *   name: 'Pet',\n *   types: [ DogType, CatType ],\n *   resolveType(value) {\n *     if (value instanceof Dog) {\n *       return DogType;\n *     }\n *     if (value instanceof Cat) {\n *       return CatType;\n *     }\n *   }\n * });\n * ```\n */\nexport class GraphQLUnionType {\n  constructor(config) {\n    var _config$extensionASTN4;\n\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.resolveType = config.resolveType;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes =\n      (_config$extensionASTN4 = config.extensionASTNodes) !== null &&\n      _config$extensionASTN4 !== void 0\n        ? _config$extensionASTN4\n        : [];\n    this._types = defineTypes.bind(undefined, config);\n    config.resolveType == null ||\n      typeof config.resolveType === 'function' ||\n      devAssert(\n        false,\n        `${this.name} must provide \"resolveType\" as a function, ` +\n          `but got: ${inspect(config.resolveType)}.`,\n      );\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLUnionType';\n  }\n\n  getTypes() {\n    if (typeof this._types === 'function') {\n      this._types = this._types();\n    }\n\n    return this._types;\n  }\n\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      types: this.getTypes(),\n      resolveType: this.resolveType,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n    };\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n}\n\nfunction defineTypes(config) {\n  const types = resolveReadonlyArrayThunk(config.types);\n  Array.isArray(types) ||\n    devAssert(\n      false,\n      `Must provide Array of types or a function which returns such an array for Union ${config.name}.`,\n    );\n  return types;\n}\n\n/**\n * Enum Type Definition\n *\n * Some leaf values of requests and input values are Enums. GraphQL serializes\n * Enum values as strings, however internally Enums can be represented by any\n * kind of type, often integers.\n *\n * Example:\n *\n * ```ts\n * const RGBType = new GraphQLEnumType({\n *   name: 'RGB',\n *   values: {\n *     RED: { value: 0 },\n *     GREEN: { value: 1 },\n *     BLUE: { value: 2 }\n *   }\n * });\n * ```\n *\n * Note: If a value is not provided in a definition, the name of the enum value\n * will be used as its internal value.\n */\nexport class GraphQLEnumType {\n  /* <T> */\n  constructor(config) {\n    var _config$extensionASTN5;\n\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes =\n      (_config$extensionASTN5 = config.extensionASTNodes) !== null &&\n      _config$extensionASTN5 !== void 0\n        ? _config$extensionASTN5\n        : [];\n    this._values = defineEnumValues(this.name, config.values);\n    this._valueLookup = new Map(\n      this._values.map((enumValue) => [enumValue.value, enumValue]),\n    );\n    this._nameLookup = keyMap(this._values, (value) => value.name);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLEnumType';\n  }\n\n  getValues() {\n    return this._values;\n  }\n\n  getValue(name) {\n    return this._nameLookup[name];\n  }\n\n  serialize(outputValue) {\n    const enumValue = this._valueLookup.get(outputValue);\n\n    if (enumValue === undefined) {\n      throw new GraphQLError(\n        `Enum \"${this.name}\" cannot represent value: ${inspect(outputValue)}`,\n      );\n    }\n\n    return enumValue.name;\n  }\n\n  parseValue(inputValue) /* T */\n  {\n    if (typeof inputValue !== 'string') {\n      const valueStr = inspect(inputValue);\n      throw new GraphQLError(\n        `Enum \"${this.name}\" cannot represent non-string value: ${valueStr}.` +\n          didYouMeanEnumValue(this, valueStr),\n      );\n    }\n\n    const enumValue = this.getValue(inputValue);\n\n    if (enumValue == null) {\n      throw new GraphQLError(\n        `Value \"${inputValue}\" does not exist in \"${this.name}\" enum.` +\n          didYouMeanEnumValue(this, inputValue),\n      );\n    }\n\n    return enumValue.value;\n  }\n\n  parseLiteral(valueNode, _variables) /* T */\n  {\n    // Note: variables will be resolved to a value before calling this function.\n    if (valueNode.kind !== Kind.ENUM) {\n      const valueStr = print(valueNode);\n      throw new GraphQLError(\n        `Enum \"${this.name}\" cannot represent non-enum value: ${valueStr}.` +\n          didYouMeanEnumValue(this, valueStr),\n        valueNode,\n      );\n    }\n\n    const enumValue = this.getValue(valueNode.value);\n\n    if (enumValue == null) {\n      const valueStr = print(valueNode);\n      throw new GraphQLError(\n        `Value \"${valueStr}\" does not exist in \"${this.name}\" enum.` +\n          didYouMeanEnumValue(this, valueStr),\n        valueNode,\n      );\n    }\n\n    return enumValue.value;\n  }\n\n  toConfig() {\n    const values = keyValMap(\n      this.getValues(),\n      (value) => value.name,\n      (value) => ({\n        description: value.description,\n        value: value.value,\n        deprecationReason: value.deprecationReason,\n        extensions: value.extensions,\n        astNode: value.astNode,\n      }),\n    );\n    return {\n      name: this.name,\n      description: this.description,\n      values,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n    };\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n}\n\nfunction didYouMeanEnumValue(enumType, unknownValueStr) {\n  const allNames = enumType.getValues().map((value) => value.name);\n  const suggestedValues = suggestionList(unknownValueStr, allNames);\n  return didYouMean('the enum value', suggestedValues);\n}\n\nfunction defineEnumValues(typeName, valueMap) {\n  isPlainObj(valueMap) ||\n    devAssert(\n      false,\n      `${typeName} values must be an object with value names as keys.`,\n    );\n  return Object.entries(valueMap).map(([valueName, valueConfig]) => {\n    isPlainObj(valueConfig) ||\n      devAssert(\n        false,\n        `${typeName}.${valueName} must refer to an object with a \"value\" key ` +\n          `representing an internal value but got: ${inspect(valueConfig)}.`,\n      );\n    return {\n      name: assertEnumValueName(valueName),\n      description: valueConfig.description,\n      value: valueConfig.value !== undefined ? valueConfig.value : valueName,\n      deprecationReason: valueConfig.deprecationReason,\n      extensions: toObjMap(valueConfig.extensions),\n      astNode: valueConfig.astNode,\n    };\n  });\n}\n\n/**\n * Input Object Type Definition\n *\n * An input object defines a structured collection of fields which may be\n * supplied to a field argument.\n *\n * Using `NonNull` will ensure that a value must be provided by the query\n *\n * Example:\n *\n * ```ts\n * const GeoPoint = new GraphQLInputObjectType({\n *   name: 'GeoPoint',\n *   fields: {\n *     lat: { type: new GraphQLNonNull(GraphQLFloat) },\n *     lon: { type: new GraphQLNonNull(GraphQLFloat) },\n *     alt: { type: GraphQLFloat, defaultValue: 0 },\n *   }\n * });\n * ```\n */\nexport class GraphQLInputObjectType {\n  constructor(config) {\n    var _config$extensionASTN6;\n\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.extensions = toObjMap(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes =\n      (_config$extensionASTN6 = config.extensionASTNodes) !== null &&\n      _config$extensionASTN6 !== void 0\n        ? _config$extensionASTN6\n        : [];\n    this._fields = defineInputFieldMap.bind(undefined, config);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLInputObjectType';\n  }\n\n  getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  }\n\n  toConfig() {\n    const fields = mapValue(this.getFields(), (field) => ({\n      description: field.description,\n      type: field.type,\n      defaultValue: field.defaultValue,\n      deprecationReason: field.deprecationReason,\n      extensions: field.extensions,\n      astNode: field.astNode,\n    }));\n    return {\n      name: this.name,\n      description: this.description,\n      fields,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n    };\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n}\n\nfunction defineInputFieldMap(config) {\n  const fieldMap = resolveObjMapThunk(config.fields);\n  isPlainObj(fieldMap) ||\n    devAssert(\n      false,\n      `${config.name} fields must be an object with field names as keys or a function which returns such an object.`,\n    );\n  return mapValue(fieldMap, (fieldConfig, fieldName) => {\n    !('resolve' in fieldConfig) ||\n      devAssert(\n        false,\n        `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`,\n      );\n    return {\n      name: assertName(fieldName),\n      description: fieldConfig.description,\n      type: fieldConfig.type,\n      defaultValue: fieldConfig.defaultValue,\n      deprecationReason: fieldConfig.deprecationReason,\n      extensions: toObjMap(fieldConfig.extensions),\n      astNode: fieldConfig.astNode,\n    };\n  });\n}\n\nexport function isRequiredInputField(field) {\n  return isNonNullType(field.type) && field.defaultValue === undefined;\n}\n"]},"metadata":{},"sourceType":"module"}