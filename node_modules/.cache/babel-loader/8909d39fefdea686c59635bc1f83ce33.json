{"ast":null,"code":"import { focusManager } from './focusManager';\nimport { onlineManager } from './onlineManager';\nimport { sleep } from './utils';\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * Math.pow(2, failureCount), 30000);\n}\n\nexport function isCancelable(value) {\n  return typeof (value == null ? void 0 : value.cancel) === 'function';\n}\nexport var CancelledError = function CancelledError(options) {\n  this.revert = options == null ? void 0 : options.revert;\n  this.silent = options == null ? void 0 : options.silent;\n};\nexport function isCancelledError(value) {\n  return value instanceof CancelledError;\n} // CLASS\n\nexport var Retryer = function Retryer(config) {\n  var _this = this;\n\n  var cancelRetry = false;\n  var cancelFn;\n  var continueFn;\n  var promiseResolve;\n  var promiseReject;\n  this.abort = config.abort;\n\n  this.cancel = function (cancelOptions) {\n    return cancelFn == null ? void 0 : cancelFn(cancelOptions);\n  };\n\n  this.cancelRetry = function () {\n    cancelRetry = true;\n  };\n\n  this.continue = function () {\n    return continueFn == null ? void 0 : continueFn();\n  };\n\n  this.failureCount = 0;\n  this.isPaused = false;\n  this.isResolved = false;\n  this.isTransportCancelable = false;\n  this.promise = new Promise(function (outerResolve, outerReject) {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n\n  var resolve = function resolve(value) {\n    if (!_this.isResolved) {\n      _this.isResolved = true;\n      config.onSuccess == null ? void 0 : config.onSuccess(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseResolve(value);\n    }\n  };\n\n  var reject = function reject(value) {\n    if (!_this.isResolved) {\n      _this.isResolved = true;\n      config.onError == null ? void 0 : config.onError(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseReject(value);\n    }\n  };\n\n  var pause = function pause() {\n    return new Promise(function (continueResolve) {\n      continueFn = continueResolve;\n      _this.isPaused = true;\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(function () {\n      continueFn = undefined;\n      _this.isPaused = false;\n      config.onContinue == null ? void 0 : config.onContinue();\n    });\n  }; // Create loop function\n\n\n  var run = function run() {\n    // Do nothing if already resolved\n    if (_this.isResolved) {\n      return;\n    }\n\n    var promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    } // Create callback to cancel this fetch\n\n\n    cancelFn = function cancelFn(cancelOptions) {\n      if (!_this.isResolved) {\n        reject(new CancelledError(cancelOptions));\n        _this.abort == null ? void 0 : _this.abort(); // Cancel transport if supported\n\n        if (isCancelable(promiseOrValue)) {\n          try {\n            promiseOrValue.cancel();\n          } catch (_unused) {}\n        }\n      }\n    }; // Check if the transport layer support cancellation\n\n\n    _this.isTransportCancelable = isCancelable(promiseOrValue);\n    Promise.resolve(promiseOrValue).then(resolve).catch(function (error) {\n      var _config$retry, _config$retryDelay; // Stop if the fetch is already resolved\n\n\n      if (_this.isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n\n      var retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      var retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      var delay = typeof retryDelay === 'function' ? retryDelay(_this.failureCount, error) : retryDelay;\n      var shouldRetry = retry === true || typeof retry === 'number' && _this.failureCount < retry || typeof retry === 'function' && retry(_this.failureCount, error);\n\n      if (cancelRetry || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n\n      _this.failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(_this.failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(function () {\n        if (!focusManager.isFocused() || !onlineManager.isOnline()) {\n          return pause();\n        }\n      }).then(function () {\n        if (cancelRetry) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n\n  run();\n};","map":{"version":3,"sources":["/Users/adammartiska/Projects/eMenu/GUI/eMenu-customer/node_modules/react-query/es/core/retryer.js"],"names":["focusManager","onlineManager","sleep","defaultRetryDelay","failureCount","Math","min","pow","isCancelable","value","cancel","CancelledError","options","revert","silent","isCancelledError","Retryer","config","_this","cancelRetry","cancelFn","continueFn","promiseResolve","promiseReject","abort","cancelOptions","continue","isPaused","isResolved","isTransportCancelable","promise","Promise","outerResolve","outerReject","resolve","onSuccess","reject","onError","pause","continueResolve","onPause","then","undefined","onContinue","run","promiseOrValue","fn","error","_unused","catch","_config$retry","_config$retryDelay","retry","retryDelay","delay","shouldRetry","onFail","isFocused","isOnline"],"mappings":"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","sourcesContent":["import { focusManager } from './focusManager';\nimport { onlineManager } from './onlineManager';\nimport { sleep } from './utils';\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * Math.pow(2, failureCount), 30000);\n}\n\nexport function isCancelable(value) {\n  return typeof (value == null ? void 0 : value.cancel) === 'function';\n}\nexport var CancelledError = function CancelledError(options) {\n  this.revert = options == null ? void 0 : options.revert;\n  this.silent = options == null ? void 0 : options.silent;\n};\nexport function isCancelledError(value) {\n  return value instanceof CancelledError;\n} // CLASS\n\nexport var Retryer = function Retryer(config) {\n  var _this = this;\n\n  var cancelRetry = false;\n  var cancelFn;\n  var continueFn;\n  var promiseResolve;\n  var promiseReject;\n  this.abort = config.abort;\n\n  this.cancel = function (cancelOptions) {\n    return cancelFn == null ? void 0 : cancelFn(cancelOptions);\n  };\n\n  this.cancelRetry = function () {\n    cancelRetry = true;\n  };\n\n  this.continue = function () {\n    return continueFn == null ? void 0 : continueFn();\n  };\n\n  this.failureCount = 0;\n  this.isPaused = false;\n  this.isResolved = false;\n  this.isTransportCancelable = false;\n  this.promise = new Promise(function (outerResolve, outerReject) {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n\n  var resolve = function resolve(value) {\n    if (!_this.isResolved) {\n      _this.isResolved = true;\n      config.onSuccess == null ? void 0 : config.onSuccess(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseResolve(value);\n    }\n  };\n\n  var reject = function reject(value) {\n    if (!_this.isResolved) {\n      _this.isResolved = true;\n      config.onError == null ? void 0 : config.onError(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseReject(value);\n    }\n  };\n\n  var pause = function pause() {\n    return new Promise(function (continueResolve) {\n      continueFn = continueResolve;\n      _this.isPaused = true;\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(function () {\n      continueFn = undefined;\n      _this.isPaused = false;\n      config.onContinue == null ? void 0 : config.onContinue();\n    });\n  }; // Create loop function\n\n\n  var run = function run() {\n    // Do nothing if already resolved\n    if (_this.isResolved) {\n      return;\n    }\n\n    var promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    } // Create callback to cancel this fetch\n\n\n    cancelFn = function cancelFn(cancelOptions) {\n      if (!_this.isResolved) {\n        reject(new CancelledError(cancelOptions));\n        _this.abort == null ? void 0 : _this.abort(); // Cancel transport if supported\n\n        if (isCancelable(promiseOrValue)) {\n          try {\n            promiseOrValue.cancel();\n          } catch (_unused) {}\n        }\n      }\n    }; // Check if the transport layer support cancellation\n\n\n    _this.isTransportCancelable = isCancelable(promiseOrValue);\n    Promise.resolve(promiseOrValue).then(resolve).catch(function (error) {\n      var _config$retry, _config$retryDelay;\n\n      // Stop if the fetch is already resolved\n      if (_this.isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n\n      var retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      var retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      var delay = typeof retryDelay === 'function' ? retryDelay(_this.failureCount, error) : retryDelay;\n      var shouldRetry = retry === true || typeof retry === 'number' && _this.failureCount < retry || typeof retry === 'function' && retry(_this.failureCount, error);\n\n      if (cancelRetry || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n\n      _this.failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(_this.failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(function () {\n        if (!focusManager.isFocused() || !onlineManager.isOnline()) {\n          return pause();\n        }\n      }).then(function () {\n        if (cancelRetry) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n\n  run();\n};"]},"metadata":{},"sourceType":"module"}