{"ast":null,"code":"import { devAssert } from '../jsutils/devAssert.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { visit, visitInParallel } from '../language/visitor.mjs';\nimport { assertValidSchema } from '../type/validate.mjs';\nimport { TypeInfo, visitWithTypeInfo } from '../utilities/TypeInfo.mjs';\nimport { specifiedRules, specifiedSDLRules } from './specifiedRules.mjs';\nimport { SDLValidationContext, ValidationContext } from './ValidationContext.mjs';\n/**\n * Implements the \"Validation\" section of the spec.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the document is valid.\n *\n * A list of specific validation rules may be provided. If not provided, the\n * default list of rules defined by the GraphQL specification will be used.\n *\n * Each validation rules is a function which returns a visitor\n * (see the language/visitor API). Visitor methods are expected to return\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\n *\n * Validate will stop validation after a `maxErrors` limit has been reached.\n * Attackers can send pathologically invalid queries to induce a DoS attack,\n * so by default `maxErrors` set to 100 errors.\n *\n * Optionally a custom TypeInfo instance may be provided. If not provided, one\n * will be created from the provided schema.\n */\n\nexport function validate(schema, documentAST) {\n  let rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : specifiedRules;\n  let options = arguments.length > 3 ? arguments[3] : undefined;\n  let typeInfo = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new TypeInfo(schema);\n\n  var _options$maxErrors;\n\n  const maxErrors = (_options$maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors) !== null && _options$maxErrors !== void 0 ? _options$maxErrors : 100;\n  documentAST || devAssert(false, 'Must provide document.'); // If the schema used for validation is invalid, throw an error.\n\n  assertValidSchema(schema);\n  const abortObj = Object.freeze({});\n  const errors = [];\n  const context = new ValidationContext(schema, documentAST, typeInfo, error => {\n    if (errors.length >= maxErrors) {\n      errors.push(new GraphQLError('Too many validation errors, error limit reached. Validation aborted.')); // eslint-disable-next-line @typescript-eslint/no-throw-literal\n\n      throw abortObj;\n    }\n\n    errors.push(error);\n  }); // This uses a specialized visitor which runs multiple visitors in parallel,\n  // while maintaining the visitor skip and break API.\n\n  const visitor = visitInParallel(rules.map(rule => rule(context))); // Visit the whole document with each instance of all provided rules.\n\n  try {\n    visit(documentAST, visitWithTypeInfo(typeInfo, visitor));\n  } catch (e) {\n    if (e !== abortObj) {\n      throw e;\n    }\n  }\n\n  return errors;\n}\n/**\n * @internal\n */\n\nexport function validateSDL(documentAST, schemaToExtend) {\n  let rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : specifiedSDLRules;\n  const errors = [];\n  const context = new SDLValidationContext(documentAST, schemaToExtend, error => {\n    errors.push(error);\n  });\n  const visitors = rules.map(rule => rule(context));\n  visit(documentAST, visitInParallel(visitors));\n  return errors;\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDL(documentAST) {\n  const errors = validateSDL(documentAST);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(error => error.message).join('\\n\\n'));\n  }\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDLExtension(documentAST, schema) {\n  const errors = validateSDL(documentAST, schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(error => error.message).join('\\n\\n'));\n  }\n}","map":{"version":3,"sources":["/Users/adammartiska/Projects/eMenu/GUI/eMenu-customer/node_modules/graphql/validation/validate.mjs"],"names":["devAssert","GraphQLError","visit","visitInParallel","assertValidSchema","TypeInfo","visitWithTypeInfo","specifiedRules","specifiedSDLRules","SDLValidationContext","ValidationContext","validate","schema","documentAST","rules","options","typeInfo","_options$maxErrors","maxErrors","abortObj","Object","freeze","errors","context","error","length","push","visitor","map","rule","e","validateSDL","schemaToExtend","visitors","assertValidSDL","Error","message","join","assertValidSDLExtension"],"mappings":"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","sourcesContent":["import { devAssert } from '../jsutils/devAssert.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { visit, visitInParallel } from '../language/visitor.mjs';\nimport { assertValidSchema } from '../type/validate.mjs';\nimport { TypeInfo, visitWithTypeInfo } from '../utilities/TypeInfo.mjs';\nimport { specifiedRules, specifiedSDLRules } from './specifiedRules.mjs';\nimport {\n  SDLValidationContext,\n  ValidationContext,\n} from './ValidationContext.mjs';\n/**\n * Implements the \"Validation\" section of the spec.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the document is valid.\n *\n * A list of specific validation rules may be provided. If not provided, the\n * default list of rules defined by the GraphQL specification will be used.\n *\n * Each validation rules is a function which returns a visitor\n * (see the language/visitor API). Visitor methods are expected to return\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\n *\n * Validate will stop validation after a `maxErrors` limit has been reached.\n * Attackers can send pathologically invalid queries to induce a DoS attack,\n * so by default `maxErrors` set to 100 errors.\n *\n * Optionally a custom TypeInfo instance may be provided. If not provided, one\n * will be created from the provided schema.\n */\n\nexport function validate(\n  schema,\n  documentAST,\n  rules = specifiedRules,\n  options,\n  /** @deprecated will be removed in 17.0.0 */\n  typeInfo = new TypeInfo(schema),\n) {\n  var _options$maxErrors;\n\n  const maxErrors =\n    (_options$maxErrors =\n      options === null || options === void 0 ? void 0 : options.maxErrors) !==\n      null && _options$maxErrors !== void 0\n      ? _options$maxErrors\n      : 100;\n  documentAST || devAssert(false, 'Must provide document.'); // If the schema used for validation is invalid, throw an error.\n\n  assertValidSchema(schema);\n  const abortObj = Object.freeze({});\n  const errors = [];\n  const context = new ValidationContext(\n    schema,\n    documentAST,\n    typeInfo,\n    (error) => {\n      if (errors.length >= maxErrors) {\n        errors.push(\n          new GraphQLError(\n            'Too many validation errors, error limit reached. Validation aborted.',\n          ),\n        ); // eslint-disable-next-line @typescript-eslint/no-throw-literal\n\n        throw abortObj;\n      }\n\n      errors.push(error);\n    },\n  ); // This uses a specialized visitor which runs multiple visitors in parallel,\n  // while maintaining the visitor skip and break API.\n\n  const visitor = visitInParallel(rules.map((rule) => rule(context))); // Visit the whole document with each instance of all provided rules.\n\n  try {\n    visit(documentAST, visitWithTypeInfo(typeInfo, visitor));\n  } catch (e) {\n    if (e !== abortObj) {\n      throw e;\n    }\n  }\n\n  return errors;\n}\n/**\n * @internal\n */\n\nexport function validateSDL(\n  documentAST,\n  schemaToExtend,\n  rules = specifiedSDLRules,\n) {\n  const errors = [];\n  const context = new SDLValidationContext(\n    documentAST,\n    schemaToExtend,\n    (error) => {\n      errors.push(error);\n    },\n  );\n  const visitors = rules.map((rule) => rule(context));\n  visit(documentAST, visitInParallel(visitors));\n  return errors;\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDL(documentAST) {\n  const errors = validateSDL(documentAST);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map((error) => error.message).join('\\n\\n'));\n  }\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDLExtension(documentAST, schema) {\n  const errors = validateSDL(documentAST, schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map((error) => error.message).join('\\n\\n'));\n  }\n}\n"]},"metadata":{},"sourceType":"module"}