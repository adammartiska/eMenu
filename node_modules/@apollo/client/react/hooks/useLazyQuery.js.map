{"version":3,"file":"useLazyQuery.js","sourceRoot":"","sources":["../../../src/react/hooks/useLazyQuery.ts"],"names":[],"mappings":";AAEA,OAAO,EAAE,WAAW,EAAE,SAAS,EAAE,QAAQ,EAAE,MAAM,OAAO,CAAC;AAQzD,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAC;AAKtC,IAAM,aAAa,GAAG;IACpB,SAAS;IACT,WAAW;IACX,aAAa;IACb,cAAc;IACd,iBAAiB;CACT,CAAC;AAEX,MAAM,UAAU,YAAY,CAC1B,KAA0D,EAC1D,OAAiD;IAE3C,IAAA,KAA4B,QAAQ,CAMxC;QACA,MAAM,EAAE,KAAK;QACb,QAAQ,EAAE,EAAE;KACb,CAAC,EATK,SAAS,QAAA,EAAE,YAAY,QAS5B,CAAC;IAEH,IAAM,OAAO,GAAG,WAAW,CAEzB,UAAC,cAA6C;QAC9C,IAAI,OAA8D,CAAC;QACnE,IAAM,OAAO,GAAG,IAAI,OAAO,CACzB,UAAC,QAAQ,IAAK,OAAA,CAAC,OAAO,GAAG,QAAQ,CAAC,EAApB,CAAoB,CACnC,CAAC;QACF,YAAY,CAAC,UAAC,SAAS;YACrB,IAAI,SAAS,CAAC,MAAM,EAAE;gBACpB,MAAM,IAAI,MAAM,CAAC,OAAO,CAAC,cAAc,aAAd,cAAc,uBAAd,cAAc,CAAE,SAAS,CAAC,CAAC;aACrD;YAED,OAAO;gBACL,MAAM,EAAE,IAAI;gBACZ,QAAQ,kCAAM,SAAS,CAAC,QAAQ,UAAE,OAAO,SAAC;gBAC1C,OAAO,EAAE,cAAc;aACxB,CAAC;QACJ,CAAC,CAAC,CAAC;QAEH,OAAO,OAAO,CAAC;IACjB,CAAC,EAAE,EAAE,CAAC,CAAC;IAEP,IAAI,MAAM,GAAG,QAAQ,CAAoB,KAAK,iCACzC,OAAO,GACP,SAAS,CAAC,OAAO,KAGpB,WAAW,EAAE,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW,CAAC,CAAC,CAAC,SAAS,EAChE,IAAI,EAAE,SAAS,IACf,CAAC;IACH,SAAS,CAAC;QACA,IAAA,QAAQ,GAAK,SAAS,SAAd,CAAe;QAC/B,IAAI,CAAC,MAAM,CAAC,OAAO,IAAI,QAAQ,CAAC,MAAM,EAAE;YACtC,YAAY,CAAC,UAAC,SAAS,IAAK,OAAA,uBAAM,SAAS,KAAE,QAAQ,EAAE,EAAE,IAAG,EAAhC,CAAgC,CAAC,CAAC;YAC9D,QAAQ,CAAC,OAAO,CAAC,UAAC,OAAO,IAAK,OAAA,OAAO,CAAC,MAAM,CAAC,EAAf,CAAe,CAAC,CAAC;SAChD;IACH,CAAC,EAAE,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC,CAAC;IAExB,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE;QACrB,MAAM,yBACD,MAAM,KACT,OAAO,EAAE,KAAK,EACd,IAAI,EAAE,KAAK,CAAqB,EAChC,KAAK,EAAE,KAAK,CAAC,EAEb,MAAM,EAAE,KAAY,GACrB,CAAC;gCAGS,GAAG;YACZ,IAAM,MAAM,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;YAC3B,MAAM,CAAC,GAAG,CAAC,GAAG;gBAAC,cAAY;qBAAZ,UAAY,EAAZ,qBAAY,EAAZ,IAAY;oBAAZ,yBAAY;;gBACzB,YAAY,CAAC,UAAC,SAAS,IAAK,OAAA,uBAAM,SAAS,KAAE,MAAM,EAAE,IAAI,IAAG,EAAhC,CAAgC,CAAC,CAAC;gBAC9D,OAAQ,MAAc,eAAI,IAAI,EAAE;YAClC,CAAC,CAAC;;QALJ,KAAkB,UAAa,EAAb,+BAAa,EAAb,2BAAa,EAAb,IAAa;YAA1B,IAAM,GAAG,sBAAA;oBAAH,GAAG;SAMb;KACF;IAGD,OAAO,CAAC,OAAO,EAAE,MAA4C,CAAC,CAAC;AACjE,CAAC","sourcesContent":["import { DocumentNode } from 'graphql';\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\nimport { useCallback, useEffect, useState } from 'react';\n\nimport {\n  LazyQueryHookOptions,\n  LazyQueryResult,\n  QueryLazyOptions,\n  QueryTuple,\n} from '../types/types';\nimport { useQuery } from './useQuery';\nimport { OperationVariables } from '../../core';\n\n// The following methods, when called will execute the query, regardless of\n// whether the useLazyQuery execute function was called before.\nconst EAGER_METHODS = [\n  'refetch',\n  'fetchMore',\n  'updateQuery',\n  'startPolling',\n  'subscribeToMore',\n] as const;\n\nexport function useLazyQuery<TData = any, TVariables = OperationVariables>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: LazyQueryHookOptions<TData, TVariables>\n): QueryTuple<TData, TVariables> {\n  const [execution, setExecution] = useState<\n    {\n      called: boolean,\n      options?: QueryLazyOptions<TVariables>,\n      resolves: Array<(result: LazyQueryResult<TData, TVariables>) => void>,\n    }\n  >({\n    called: false,\n    resolves: [],\n  });\n\n  const execute = useCallback<\n    QueryTuple<TData, TVariables>[0]\n  >((executeOptions?: QueryLazyOptions<TVariables>) => {\n    let resolve!: (result: LazyQueryResult<TData, TVariables>) => void;\n    const promise = new Promise<LazyQueryResult<TData, TVariables>>(\n      (resolve1) => (resolve = resolve1),\n    );\n    setExecution((execution) => {\n      if (execution.called) {\n        result && result.refetch(executeOptions?.variables);\n      }\n\n      return {\n        called: true,\n        resolves: [...execution.resolves, resolve],\n        options: executeOptions,\n      };\n    });\n\n    return promise;\n  }, []);\n\n  let result = useQuery<TData, TVariables>(query, {\n    ...options,\n    ...execution.options,\n    // We donâ€™t set skip to execution.called, because we need useQuery to call\n    // addQueryPromise, so that ssr calls waits for execute to be called.\n    fetchPolicy: execution.called ? options?.fetchPolicy : 'standby',\n    skip: undefined,\n  });\n  useEffect(() => {\n    const { resolves } = execution;\n    if (!result.loading && resolves.length) {\n      setExecution((execution) => ({ ...execution, resolves: [] }));\n      resolves.forEach((resolve) => resolve(result));\n    }\n  }, [result, execution]);\n\n  if (!execution.called) {\n    result = {\n      ...result,\n      loading: false,\n      data: void 0 as unknown as TData,\n      error: void 0,\n      // TODO: fix the type of result\n      called: false as any,\n    };\n\n\n    for (const key of EAGER_METHODS) {\n      const method = result[key];\n      result[key] = (...args: any) => {\n        setExecution((execution) => ({ ...execution, called: true }));\n        return (method as any)(...args);\n      };\n    }\n  }\n\n  // TODO: fix the type of result\n  return [execute, result as LazyQueryResult<TData, TVariables>];\n}\n"]}